#+TITLE: Criando um "MMO-RPG"
#+SUBTITLE: com Zig, Erlang, Nix e PostgreSQL

:SETTINGS:
#+STARTUP: inlineimages
#+STARTUP: beamer
#+AUTHOR: Marcos Benevides
#+EMAIL: marcos.schonfinkel@gmail.com
#+DATE: <2025-09-07 Sun>
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  pt
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_LINK_UP:
#+HTML_LINK_HOME: https://github.com/dont-rely-on-nulls/gambiconf-2025

#+beamer_theme: SimplePlus
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LATEX_HEADER: \input{./tex/template.tex}
#+LATEX_HEADER: \usepackage[backend=bibtex]{biblatex}
#+LATEX_HEADER: \addbibresource{./references.bib}
#+LATEX_HEADER: \bibliographystyle{authordate1}
#+bibliography: references
:END:

* IntroduÃ§Ã£o

** ProgramaÃ§Ã£o Recreativa

#+ATTR_BEAMER: :overlay +-
+ [[https://github.com/Dr-Nekoma][Dr. Nekoma]]: Projeto dedicado Ã  programaÃ§Ã£o recreativa e exploraÃ§Ã£o de tÃ³picos
  nichados e sem influÃªncias mainstream. Comumente se materializa na forma de
  projetos bizarros (praticidade questionÃ¡vel).

+ [[https://github.com/dont-rely-on-nulls][Dont Rely on Nulls]]: Uma iniciativa que se destina a empreendimentos mais
  sÃ©rios. Por via de regra, projetos do "Dr. Nekoma" que se tornem sÃ©rios acabam
  sendo migrados e aprimorados nessa organizaÃ§Ã£o (i.e. [[https://github.com/dont-rely-on-nulls/zerl][Zerl]]).

** Contexto

#+ATTR_BEAMER: :overlay +-
+ Este Ã© um ambiente recreativo.
+ Temos toda a liberdade que nÃ£o nos Ã© permitida durante (a maioria) dos
  empregos de tempo integral.
+ Quais sÃ£o as coisas que sonhamos em ter?
+ Como podemos fazer isso acontecer?

** MissÃ£o

O projeto deve ter as seguintes caracterÃ­sticas:

#+ATTR_BEAMER: :overlay +-
1. Deve ser rÃ¡pido (considerando que Ã© um jogo), mas sem precisar recorrer ao Rust.
2. GrÃ¡ficos fÃ¡ceis sem a dor de cabeÃ§a das APIs grÃ¡ficas.
3. Uma fonte Ãºnica de verdade.
4. Server distribuÃ­do e tolerante a falhas.
5. Ambiente de desenvolvimento reproduzÃ­vel, isolado e declarativo, que assume
   apenas a existÃªncia de algum editor de texto e 0 pacotes instalados
   globalmente. _Todos os componentes devem rodar localmente_.

** Resposta:

#+ATTR_LATEX: :width 0.8\linewidth
| Propriedade                             | Ferramenta            |
|-----------------------------------------+-----------------------|
| Deve ser rÃ¡pido                         | [[https://ziglang.org/][Zig]]                   |
| GrÃ¡ficos fÃ¡ceis                         | [[https://www.raylib.com/][Raylib]]                |
| Uma fonte Ãºnica de verdade              | [[https://www.postgresql.org/][PostgreSQL]] + [[https://omnigres.com/][Omnigres]] |
| Server distribuÃ­do e tolerante a falhas | [[https://www.erlang.org/][Erlang/OTP]]            |
| Ambiente de desenvolvimento             | Nix Shells e [[https://nixos.org/][NixOS]]    |

* Zig

** Zig \leftrightarrow Raylib

** Zig \harr C Nodes \leftrightarrow ~Erl_Interface~

*** Interface com Erlang
:PROPERTIES:
:BEAMER_ENV: block
:END:

#+ATTR_BEAMER: :overlay +-
+ ~C Nodes~ sÃ£o programas que atuam como nÃ³s ocultos dentro de um sistema Erlang
  distribuÃ­do, permitindo que aplicaÃ§Ãµes escritas em linguagens nÃ£o suportadas
  nativamente pela BEAM participem de clusters Erlang.
+ Utilizam a biblioteca ~Erl_Interface~ para se comunicar com outros nÃ³s via
  TCP/IP, como se fossem nÃ³s Erlang nativos.
+ A ~Erl_Interface~ fornece funÃ§Ãµes para integrar programas em C com sistemas
  Erlang, servindo como base para a criaÃ§Ã£o de ~C Nodes~.

** Zerl

*** Estabelecendo a ponte entre Erlang e Zig
:PROPERTIES:
:BEAMER_ENV: block
:END:

#+ATTR_BEAMER: :overlay +-
+ Inicialmente uma biblioteca interna do jogo, foi criada para traduzir de forma
  idiomÃ¡tica tipos em Zig \rightarrow Erlang (e vice versa).
+ Depois de vÃ¡rias iteraÃ§Ãµes e redesigns acabou virando um pacote separado.
+ Wrapper para a ~Erl_Interface~.

** Func Prog Sweden (2024)

#+CAPTION: [[https://www.youtube.com/watch?v=ejYcWRERetM][Zerl: Making Zig in the BEAM an ez time]], Eduardo Lemos.
#+NAME: fig:zerl-presentation
[[./img/zerl_presentation.jpg]]


* Nix

** O que Ã© Nix?

** Nixpkgs

** Nix Shell

** Nix nÃ£o Ã© Docker

** Devenv

+ ConfiguraÃ§Ã£o declarativa, que tambÃ©m permite a _composiÃ§Ã£o_ de ambientes diferentes.
+ ConfiguraÃ§Ã£o integrada para linguagens populares (Python, Rust, PHP,
  JavaScript, etc).
+ MÃ³dulos para serviÃ§oes populares como PostgreSQL, Redis, MySQL, RabbitMQ, etc.
+ Gerenciamento de processos, suporte para ~git~ hooks.
+ Acesso a todos pacotes do [[https://search.nixos.org/packages?channel=unstable&][nixpkgs]] (atualmente mais the 120K).

** Devenv (Demo #1)

#+begin_src shell
  cd lyceum
  nix develop --impure
#+end_src

ou, se vocÃª estiver usando [[https://github.com/direnv/direnv][direnv]] (com [[https://github.com/nix-community/nix-direnv][nix-direnv]])

#+begin_src shell
  cd lyceum
  nix develop --impure
#+end_src

** Escada de AbstraÃ§Ãµes

* Erlang

** Erlang Node

** Criando Processos com ~spawn/3~

#+ATTR_LATEX: :width 0.7\linewidth
#+begin_src erlang
  Pid2 = spawn(ModName, FuncName, [Arg1, ..., ArgN]).
#+end_src

#+NAME: erlang-process
#+BEGIN_SRC dot :file ./img/erlang_process.png :cmdline -Kdot -Tpng :exports results
  digraph Spawn {
    node [shape=circle];
    sep = 1;
  
    pid1 [label="Pid 1", fontsize="10pt", style=filled, fillcolor=grey];
    pid2 [label="Pid 2", xlabel="Mod:Func(Args)", fontsize="10pt", style=filled, fillcolor=white];
  
    pid1 -> pid2 [label="  Spawn(Mod, Func, Args)", fontsize="10pt", minlen=1, style=dashed];
  }
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+CAPTION: [cite:@cesarini2016designing p.29 chapter.2]
#+RESULTS: erlang-process
[[file:./img/erlang_process.png]]

** Message Passing

#+ATTR_LATEX: :width 0.7\linewidth
#+begin_src erlang
  Pid2 ! { Pid1, hello }.
#+end_src

#+NAME: erlang-message-passing
#+BEGIN_SRC dot :file ./img/erlang_message_passing.png :cmdline -Kdot -Tpng :exports results
  digraph Send {
    node [shape=circle];
    rankdir="LR";

    pid1 [label="Pid 1", xlabel="Pid2 ! { self(), hello }", fontsize="10pt", style=filled, fillcolor=grey];
    pid2 [label="Pid 2", fontsize="10pt", style=filled, fillcolor=white, xlabel="receive (...) end." ];

    pid1 -> pid2 [label="{ Pid1, hello }", fontsize="10pt", style=dashed];
  }
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+RESULTS: erlang-message-passing
[[file:./img/erlang_message_passing.png]]

** Anatomia de um Processo

#+NAME: erlang-process-skeleton
#+BEGIN_SRC dot :file ./img/erlang_process_skeleton.png :cmdline -Kdot -Tpng :exports results
  digraph Process {
    node [fontsize="10pt", style=filled];
    
    start [label="Start", fillcolor=gray, shape=circle];
    stop [label="Stop", fillcolor=red, shape=circle];
    init [label="Initialize", xlabel="Mod:Func(Args)", fillcolor=yellow, shape=rectangle];
    loop [label="Receive/Eval Loop", fillcolor=green, shape=rectangle]
    terminate [label="Terminate", fillcolor=yellow, shape=rectangle];

    start -> init [label="  Spawn(Mod, Func, Args)", fontsize="10pt", minlen=1];
    init -> loop
    loop -> loop
    stop -> loop
    loop -> terminate
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+CAPTION: [cite:@cesarini2016designing p.55 chapter.3]
#+RESULTS: erlang-process-skeleton
[[file:./img/erlang_process_skeleton.png]]

** Let it Crash \rightarrow Let it Heal

*** TODO Minor point about Erlang's Philosophy and how people misuderstand it

** OTP (I)
+ Open Telecom Platform

*** TODO Minor points about history and why people at Ericsoon came up with OTP
*** TODO Maybe reference this

#+BEGIN_QUOTE
OTP is a domain-independent set of frameworks, principles, and patterns that
guide and support the structure, design, implementation, and deployment of
Erlang systems. Using OTP in your projects will help you avoid *accidental
complexity: things that are difficult because you picked inadequate tools*.

OTP is said to consist of three building blocks that, when used together,
provide a solid approach to designing and developing systems in the problem
domain weâ€™ve just described. They are *Erlang* itself, *tools* and *libraries*, and a
set of *design principles*. [cite:@cesarini2016designing p.4]
#+END_QUOTE

** OTP Applications

+ Uma ~Application~ Ã© um constructor bÃ¡sico para deploy de projetos em Erlang/OTP.
+ SÃ£o processos que ser iniciados, interrompidos e gerenciadas de forma independente.

** OTP Supervisors

#+begin_quote
A supervision tree is a tree of processes. The upper processes (supervisors) in
the tree monitor the lower processes (workers) in the tree and restart the lower
processes if they fail. [cite:@armstrong2013 p.398]
#+end_quote

Independentemente do que os processos monitados faÃ§am, um supervisor funciona
sempre do mesmo modo e seu funcionao pode ser dividido em duas categorias:

+ Uma parte genÃ©rica que lida com a criaÃ§Ã£o, monitoramento e ~restart~ de
  processos filhos.
+ Uma especificaÃ§Ã£o de como os processos filhos devem ser iniciados e reiniciados.

** OTP Supervisors (~one_for_one~)

+ ~one_for_one~ :: Se um processo monitorado morre, deve ser reiniciado.

#+NAME: fig:erlang-supervisor-o4o
#+BEGIN_SRC dot :file ./img/erlang_supervisor_o4o.png :cmdline -Kdot -Tpng :exports results
  graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
        label="", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
  	]

  	sup [label="S", pos="1,1"]
  	w1 [pos="0,0"]
  	w2 [pos="0,1"]
  	w3 [label="ðŸ”¥", pos="0,2"]
  	w4 [pos="0,3"]

  	sup -- w1
  	sup -- w2
  	sup -- w3
  	sup -- w4
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: fig:erlang-supervisor-o4o
[[file:./img/erlang_supervisor_o4o.png]]

** OTP Supervisors (~one_for_all~)

+ ~one_for_all~ :: Se um processo monitorado morre, todos devem ser reiniciado.

#+NAME: fig:erlang-supervisor-o4a
#+BEGIN_SRC dot :file ./img/erlang_supervisor_o4a.png :cmdline -Kdot -Tpng :exports results
  graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
        label="âŸ³", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
  	]

  	sup [label="S", pos="1,1"]
  	w1 [pos="0,0"]
  	w2 [pos="0,1"]
  	w3 [label="ðŸ”¥", pos="0,2"]
  	w4 [pos="0,3"]

  	sup -- w1
  	sup -- w2
  	sup -- w3
  	sup -- w4
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: fig:erlang-supervisor-o4a
[[file:./img/erlang_supervisor_o4a.png]]

** ~gen_server~ (I)

+ Fornece uma interface para implementar processos que respondem a requisiÃ§Ãµes
  sÃ­ncronas (~call~) e assÃ­ncronas (~cast~).

#+NAME: fig:erlang-client-server
#+BEGIN_SRC dot :file ./img/erlang-client-server.png :cmdline -Kneato -Tpng :exports results
digraph client_server {
    rankdir=LR;
    node [shape=circle, label="", style=filled, fillcolor=white, width=0.8];
    edge [fontsize=10, width=0.5];
    
    // Clients
    client1 [xlabel="Client 1", pos="0,2!"];
    client2 [xlabel="Client 2", pos="0,1!"];  
    client3 [xlabel="Client 3", pos="0,0!"];
    
    // Server
    server [xlabel="Server", pos="4,1!"];
        
    // Query/Reply arrows
    client1 -> server [style=solid];
    client2 -> server [style=solid];
    client3 -> server [style=solid];
     
    server -> client1 [style=dashed];
    server -> client2 [style=dashed];
    server -> client3 [style=dashed];
}
#+END_SRC

#+ATTR_LATEX: :width 0.7\linewidth
#+RESULTS: fig:erlang-client-server
[[file:./img/erlang-client-server.png]]

** ~gen_server~ (II)

+ Gerenciamento de ciclo de vida padronizado: inicializaÃ§Ã£o e outras transiÃ§Ãµes
  de estado sÃ£o feitas de forma consistente.
+ Podem ser facilmente integrados em Ã¡rvores de supervisÃ£o.

#+NAME: fig:erlang-gen_server
#+BEGIN_SRC dot :file ./img/erlang-gen_server.png :cmdline -Kdot -Tpng :exports results
digraph gen_server {
  rankdir=LR;
  node [shape=box, style=filled];
  edge [dir=both];
  
  graph [margin=0.2];
  
  api [label="API\n\nstart_link()\n(...)", 
        fillcolor=lightblue, 
        width=2, 
        height=1.5,
        fontsize=12];
  
  process [label="gen_server\nProcess", 
            shape=circle, 
            fillcolor=gray70,
            width=1.2,
            fontsize=11];
  
  callbacks [label="Callback Module\n\ninit/1\nhandle_call/3\nhandle_cast/2\nterminate/2", 
              fillcolor=lightcyan,
              width=2,
              height=1.5,
              fontsize=12];
  
  api -> process [arrowhead=normal, arrowtail=normal];
  process -> callbacks [arrowhead=normal, arrowtail=normal];
}
#+END_SRC

#+ATTR_LATEX: :width 0.7\linewidth
#+CAPTION: [cite:@cesarini2016designing p.58 chapter.3]
#+RESULTS: fig:erlang-gen_server
[[file:./img/erlang-gen_server.png]]
** ~gen_statem~ (I)

#+ATTR_BEAMER: :overlay +-
+ Gerenciamento de Estado Estruturado: Oferece uma interface para implementar
  mÃ¡quinas de estados finitos com estados e transiÃ§Ãµes bem definidos.
+ Processamento Orientado a Eventos: Lida com mÃºltiplos tipos de eventos
  (chamadas, conversÃµes, mensagens informativas, timeouts) e os encaminha para
  manipuladores de estado apropriados, com suporte para adiamento de eventos e
  geraÃ§Ã£o interna de eventos.

** ~gen_statem~ (II)

*** TODO Show the player FSM

** Combinando as Estruturas (I)

#+NAME: erlang-app-structure
#+BEGIN_SRC dot :file ./img/erlang_app_structure.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Supervisor", pos="1,1", fillcolor="blue"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  w4 [label="P4", pos="0,3"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
  sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure
[[file:./img/erlang_app_structure.png]]

** Combinando as Estruturas (II)

#+NAME: erlang-app-structure-ii
#+BEGIN_SRC dot :file ./img/erlang_app_structure_ii.png :cmdline -Kdot -Tpng :exports results
graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
  		label="", 
  		xlabel="",
  		shape=circle,
  		fixedsize=true,
  		width=0.3,
  		color="black",
  		fillcolor="white",
  		style="filled,solid",
  		fontsize=12
  	]

  	app [xlabel="Application", pos="1,1", fillcolor="red"]
  	sup [xlabel="Top Level Supervisor", pos="1,1", fillcolor="blue"]
  	isup [xlabel="Inner Supervisor", pos="0,0", fillcolor="blue"]
	
	iw1 [label="P1", pos="0,1"]
	iw2 [label="P2", pos="0,1"]
  	w2 [label="P3", pos="0,1"]
  	w3 [label="P4", pos="0,2"]
  	w4 [label="P5", pos="0,3"]

  	app -- sup
  	sup -- isup
	isup -- iw1
	isup -- iw2
  	sup -- w2
  	sup -- w3
  	sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-ii
[[file:./img/erlang_app_structure_ii.png]]

** Combinando as Estruturas (III)

#+NAME: erlang-app-structure-iii-1
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iii_1.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="#90D5FF"]

  app -- sup
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-iii-1
[[file:./img/erlang_app_structure_iii_1.png]]

** Combinando as Estruturas (III)

#+NAME: erlang-app-structure-iii-2
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iii_2.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="#90D5FF"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-iii-2
[[file:./img/erlang_app_structure_iii_2.png]]

** Combinando as Estruturas (IV)

#+NAME: erlang-app-structure-iv
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iv.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup1 [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="#90D5FF"]
  sup2 [pos="1,2", fillcolor="blue"]
  sup3 [pos="1,3", fillcolor="blue"]
  sup4 [pos="1,4", fillcolor="#90D5FF"]
  sup5 [pos="1,5", fillcolor="#90D5FF"]

  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]

  w4 [label="P4", pos="0,3"]
  w5 [label="P5", pos="0,4"]

  w6 [label="P6", pos="0,5"]
  w7 [label="P7", pos="0,6"]

  w8 [label="P8", pos="0,7"]
  w9 [label="P9", pos="0,8"]
  
  app -- sup1
  app -- sup2
  app -- sup3
  sup1 -- w1
  sup1 -- w2
  sup1 -- w3

  sup2 -- w4
  sup2 -- w5

  sup3 -- sup4
  sup3 -- sup5

  sup4 -- w6
  sup4 -- w7

  sup5 -- w8
  sup5 -- w9
}
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+RESULTS: erlang-app-structure-iv
[[file:./img/erlang_app_structure_iv.png]]

** Releases

+ MÃ³dulos: O nÃ­vel mais baixo de encapsulamento.
+ ~Applications~: Um agrupamento mÃ³dulos, estrutura de nÃ­vel intermediÃ¡rio.
+ ~Releases~: Um agrupamento de uma ou mais aplicaÃ§Ãµes.

#+NAME: erlang-release
#+BEGIN_SRC dot :file ./img/erlang_release.png :cmdline -Kdot -Tpng :exports results
graph Release {
  ratio=fill
  splines=spline
  overlap=scale
  
  subgraph cluster_release {
    label="App v0.1.0"
    
    node [
      label="", 
      xlabel="",
      shape=circle,
      fixedsize=true,
      width=0.3,
      color="black",
      fillcolor="white",
      style="filled,solid",
      fontsize=12
    ]
    
    app [pos="1,1", fillcolor="red"]
    sup1 [pos="1,1", fillcolor="#90D5FF"]
    sup2 [pos="1,2", fillcolor="blue"]
    sup3 [pos="1,3", fillcolor="blue"]
    sup4 [pos="1,4", fillcolor="#90D5FF"]
    sup5 [pos="1,5", fillcolor="#90D5FF"]

    w1 [label="P1", pos="0,0"]
    w2 [label="P2", pos="0,1"]
    w3 [label="P3", pos="0,2"]

    w4 [label="P4", pos="0,3"]
    w5 [label="P5", pos="0,4"]

    w6 [label="P6", pos="0,5"]
    w7 [label="P7", pos="0,6"]

    w8 [label="P8", pos="0,7"]
    w9 [label="P9", pos="0,8"]
    
    app -- sup1
    app -- sup2
    app -- sup3
    sup1 -- w1
    sup1 -- w2
    sup1 -- w3

    sup2 -- w4
    sup2 -- w5

    sup3 -- sup4
    sup3 -- sup5

    sup4 -- w6
    sup4 -- w7

    sup5 -- w8
    sup5 -- w9
  }
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-release
[[file:./img/erlang_release.png]]

** Umbrellas

#+NAME: erlang-umbrella
#+BEGIN_SRC dot :file ./img/erlang_umbrella.png :cmdline -Kdot -Tpng :exports results
digraph ServerUmbrella {
  rankdir=TB;
  compound=true;
  newrank=true;
  splines=ortho;
  
  node [shape=box, style=filled, fontname="Arial", fontsize=10, fontcolor=white];
  edge [fontname="Arial", fontsize=5, color="#374151"];
  
  // Umbrella Subgraph
  subgraph cluster_server {
    label="Server Umbrella";
    style=filled;
    fillcolor="#f8fafc";
    color="#0f172a";
    penwidth=4;
    fontcolor="#0f172a";
    fontsize=14;
    
    subgraph cluster_auth {
      label="Auth";
      style=filled;
      fillcolor="#dbeafe";
      color="#1e40af";
      penwidth=3;
      fontsize=12;
      
      AA [label="Auth Application", fillcolor="#1a365d"];
      AS [label="Auth Supervisor", fillcolor="#b91c1c"];
      SAW [label="Simple Auth Worker", fillcolor="#059669"];

      AA -> AS;
      AS -> SAW;
    }
    
    subgraph cluster_world {
      label="World";
      style=filled;
      fillcolor="#dcfce7";
      color="#16a34a";
      penwidth=3;
      fontsize=12;
      
      WA [label="World Application", fillcolor="#1a365d"];
      WS [label="World Supervisor", fillcolor="#b91c1c"];
      WM [label="World Migrations", fillcolor="#059669"];
      WM1 [label="Map 1", fillcolor="#059669"];

      WA -> WS;
      WS -> WM1;
      WS -> WM;
    }
    
    subgraph cluster_player {
      label="Player";
      style=filled;
      fillcolor="#fed7aa";
      color="#ea580c";
      penwidth=3;
      fontsize=12;
      
      PA [label="Player Application", fillcolor="#1a365d"];
      TPLS [label="Top-Level Supervisor", fillcolor="#dc2626"];
      DPS1 [label="Dynamic Supervisor", fillcolor="#aa3600"];
      DPS2 [label="Dynamic Supervisor", fillcolor="#aa3600"];
      DPS3 [label="Dynamic Supervisor", fillcolor="#aa3600"];
      DPSN [label="Dynamic Supervisor", fillcolor="#aa3600"];

      P1 [label="Player 1", fillcolor="#059669"];
      P2 [label="Player 2", fillcolor="#059669"];
      P3 [label="Player 3", fillcolor="#059669"];
      PN [label="Player N", fillcolor="#059669"];

      PA -> TPLS;
  
      TPLS -> DPS1;
      DPS1 -> P1;

      TPLS -> DPS2;
      DPS2 -> P2;

      TPLS -> DPS3;
      DPS3 -> P3;

      TPLS -> DPSN;
      DPSN -> PN;
    }
    
    subgraph cluster_cache {
      label="Cache";
      style=filled;
      fillcolor="#f3e8ff";
      color="#9333ea";
      penwidth=3;
      fontsize=12;
      
      CA [label="Cache Application", fillcolor="#1a365d"];
      CS [label="Cache Supervisor", fillcolor="#b91c1c"];
      CW [label="Cache Worker", fillcolor="#059669"];
      MNESIA [label="MNESIA", shape=cylinder, fillcolor="#374151"];

      CA -> CS;
      CS -> CW;
      CW -> MNESIA [dir=both];
    }
    
    subgraph cluster_libraries {
      label="Utility Libraries";
      style=filled;
      fillcolor="#f1f5f9";
      color="#475569";
      penwidth=3;
      fontsize=12;
      fontname="Arial Bold";
      
      LPG [label="PostgreSQL Library", fillcolor="#7c3aed", style="filled,dashed"];
      LMAP [label="Map Library", fillcolor="#7c3aed", style="filled,dashed"];
    }
  }
}
#+END_SRC

#+ATTR_LATEX: :width \linewidth
#+RESULTS: erlang-umbrella
[[file:./img/erlang_umbrella.png]]

* PostgreSQL

** Schemas

+ 
  
** 6NF

** Omnigres

+ Trabalhamos junto com o mantenedor para empactor o projeto no nixpkgs.

* NixOS

** Servidor NixOS Declarativo

+ 
  
** NixOS (Demo #3)

+ 

* Fim

:PROPERTIES:
:BEAMER_env: appendix
:END:

** Perguntas?

*** Projetos
:PROPERTIES:
:BEAMER_ENV: block
:END:
- [[https://github.com/Dr-Nekoma/lyceum][Lyceum]]
- [[https://github.com/dont-rely-on-nulls/zerl][Zerl]]
- [[https://github.com/Dr-Nekoma/trashcan][Trashcan]]: Servidor NixOS

*** Slides
:PROPERTIES:
:BEAMER_ENV: block
:END:
- [[https://github.com/dont-rely-on-nulls/gambiconf-2025][Gambiconf 2025]]

** Bibliografia
  :PROPERTIES:
  :BEAMER_OPT: fragile,allowframebreaks,label=
  :END:      

#+print_bibliography:
