#+TITLE: Criando um "MMO-RPG"
#+SUBTITLE: com Zig, Erlang, Nix e PostgreSQL (e Emacs)
#+AUTHOR: Marcos Benevides \href{https://github.com/schonfinkel}{\faGithub} \href{https://www.linkedin.com/in/schonfinkel/}{\faLinkedin} \href{https://schonfinkel.github.io/}{\faGlobe}
#+DATE: \today

:SETTINGS:
#+STARTUP: inlineimages
#+STARTUP: beamer
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  pt
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_LINK_UP:
#+HTML_LINK_HOME: https://github.com/dont-rely-on-nulls/gambiconf-2025

#+beamer_theme: SimplePlus
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LATEX_HEADER: \institute{Terrateam (\href{https://terrateam.io/}{terrateam.io})}
#+LATEX_HEADER: \input{./tex/template.tex}
#+LATEX_HEADER: \usepackage[backend=bibtex]{biblatex}
#+LATEX_HEADER: \addbibresource{./references.bib}
#+LATEX_HEADER: \bibliographystyle{authordate1}
#+LATEX_HEADER: \titlegraphic{\includegraphics[width=0.2\linewidth]{./img/gambiconf_logo.png}}
#+BEAMER_HEADER: \AtBeginSection[]{\begin{frame}<beamer>\frametitle{\secname} \secbody \end{frame}}
:END:

* Introdu√ß√£o

** Objetivos

*** Programa√ß√£o Declarativa :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

+ Programa√ß√£o Declarativa
+ Composi√ß√£o
+ Boa fundamenta√ß√£o te√≥rica \rightarrow Simplicidade.

V√°rias ideias podem ser encontradas em [cite: @van2004concepts p.111 chapter.3].

*** Livro :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+ATTR_LATEX: :width 0.7\linewidth
    [[./img/ctm.jpg]]

** Programa√ß√£o Recreativa

#+ATTR_BEAMER: :overlay +-
+ [[https://github.com/Dr-Nekoma][Dr. Nekoma]]: Projeto dedicado √† programa√ß√£o recreativa e explora√ß√£o de t√≥picos
  nichados e sem influ√™ncias mainstream. Comumente se materializa na forma de
  projetos bizarros (praticidade question√°vel).

+ [[https://github.com/dont-rely-on-nulls][Dont Rely on Nulls]]: Uma iniciativa que se destina a empreendimentos mais
  s√©rios. Por via de regra, projetos do "Dr. Nekoma" que se tornem s√©rios acabam
  sendo migrados e aprimorados nessa organiza√ß√£o (i.e. [[https://github.com/dont-rely-on-nulls/zerl][Zerl]]).
  
** Contexto

#+ATTR_BEAMER: :overlay +-
+ Este √© um ambiente recreativo.
+ Temos toda a liberdade que n√£o nos √© permitida durante (a maioria) dos
  empregos de tempo integral.
+ Quais s√£o as coisas que sonhamos em ter?
+ Como podemos fazer isso acontecer?

** Miss√£o

O projeto deve ter as seguintes caracter√≠sticas:

#+ATTR_BEAMER: :overlay +-
1. Deve ser r√°pido (considerando que √© um jogo), mas sem precisar recorrer ao Rust.
2. Gr√°ficos f√°ceis sem a dor de cabe√ßa das APIs gr√°ficas.
3. Uma fonte √∫nica de verdade.
4. Server distribu√≠do e tolerante a falhas.
5. Ambiente de desenvolvimento reproduz√≠vel, isolado e declarativo, que assume
   apenas a exist√™ncia de algum editor de texto e 0 pacotes instalados
   globalmente. _Todos os componentes devem rodar localmente_.

** Resposta:

#+ATTR_LATEX: :width 0.8\linewidth
| Propriedade                             | Ferramenta            |
|-----------------------------------------+-----------------------|
| Deve ser r√°pido                         | [[https://ziglang.org/][Zig]]                   |
| Gr√°ficos f√°ceis                         | [[https://www.raylib.com/][Raylib]]                |
| Uma fonte √∫nica de verdade              | [[https://www.postgresql.org/][PostgreSQL]] + [[https://omnigres.com/][Omnigres]] |
| Server distribu√≠do e tolerante a falhas | [[https://www.erlang.org/][Erlang/OTP]]            |
| Ambiente de desenvolvimento             | Nix Shells e [[https://nixos.org/][NixOS]]    |

* Zig

** Zig \leftrightarrow Raylib

#+ATTR_BEAMER: :overlay +-
+ [[https://ziglang.org/][Zig]]: Uma linguagem de programa√ß√£o focada em *desempenho*, *seguran√ßa* e *controle
  expl√≠cito* sobre a mem√≥ria, tamb√©m fornece boa *interoperabilidade* com C.

+ [[https://www.raylib.com/][raylib]]: Uma biblioteca para criar aplicativos gr√°ficos e jogos, que fornece
  uma API simples para gr√°ficos, entrada e √°udio.

    #+CAPTION: Lyceum, pr√© v0.1.0.
    #+NAME: fig:lyceum-pre-v0-1-0
    #+ATTR_LATEX: :width 0.65\linewidth
    [[./img/lyceum_pre_v_0_1_0.png]]

** Zig \harr ~ei.h~ \leftrightarrow C Nodes

*** Interface com Erlang
:PROPERTIES:
:BEAMER_ENV: block
:END:

#+ATTR_BEAMER: :overlay +-
+ ~C Nodes~ s√£o programas que atuam como n√≥s ocultos dentro de um sistema Erlang
  distribu√≠do, permitindo que aplica√ß√µes escritas em linguagens n√£o suportadas
  nativamente pela BEAM participem de clusters Erlang.
+ Utilizam a biblioteca ~Erl_Interface~ (~ei.h~) para se comunicar com outros n√≥s via
  TCP/IP, como se fossem n√≥s Erlang nativos.

** Zerl

*** Estabelecendo a ponte entre Erlang e Zig
:PROPERTIES:
:BEAMER_ENV: block
:END:

#+ATTR_BEAMER: :overlay +-
+ Inicialmente uma biblioteca interna do jogo, foi criada para traduzir de forma
  idiom√°tica tipos em Zig \rightarrow Erlang (e vice versa).
+ Depois de v√°rias itera√ß√µes e redesigns acabou virando um pacote separado.

** Func Prog Sweden (2024)

#+CAPTION: [[https://www.youtube.com/watch?v=ejYcWRERetM][Zerl: Making Zig in the BEAM an ez time]], Eduardo Lemos.
#+NAME: fig:zerl-presentation
[[./img/zerl_presentation.jpg]]


* Erlang

** Erlang Node

#+CAPTION: Representa√ß√£o esquem√°tica de duas m√°quinas distintas, cada uma com nodes Erlang executando m√∫ltiplos aplicativos sobre a stack completa [cite: @areias2025 p.3 part.2]
#+ATTR_LATEX: :width 0.6\linewidth
[[./img/erlang_node.png]]

+ Uma ~Erlang Node~ √© uma inst√¢ncia em execu√ß√£o do Erlang Runtime System (ERTS).
+ Processos em diferentes n√≥s podem enviar e receber mensagens entre si.

** Processos em Erlang (Demo #1)

*** Erlang Demo                                                     :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :END:

#+CAPTION: Adatap√ß√£o de [cite: @cesarini2009erlang p.107 chap.4]
#+ATTR_LATEX: :width \linewidth
[[./img/erlang_demo.png]]

*** Exemplo                                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.4
    :BEAMER_envargs: <2->
    :END:

    #+begin_src shell
     $ ./benchmark.sh
     Creating 1000000
     processes took
     1047 milliseconds
    #+end_src


** Criando Processos com ~spawn/3~

#+ATTR_LATEX: :width 0.7\linewidth
#+CAPTION: A fun√ß√£o ~spawn/3~ cria um processo do m√≥dulo "~Mod~", rodando a fun√ß√£o "~FunName~" com argumentos ~[Arg1, ..., ArgN]~, e retorna o Id do novo Processo (~Pid2~).
#+begin_src erlang
  Pid2 = spawn(ModName, FuncName, [Arg1, ..., ArgN]).
#+end_src

#+NAME: erlang-process
#+BEGIN_SRC dot :file ./img/erlang_process.png :cmdline -Kdot -Tpng :exports results
  digraph Spawn {
    node [shape=circle];
    sep = 1;
  
    pid1 [label="Pid 1", fontsize="10pt", style=filled, fillcolor=grey];
    pid2 [label="Pid 2", xlabel="Mod:Func(Args)", fontsize="10pt", style=filled, fillcolor=grey];
  
    pid1 -> pid2 [label="  spawn(Mod, Func, Args)", fontsize="10pt", minlen=1, style=dashed];
  }
#+END_SRC

#+ATTR_LATEX: :width 0.6\linewidth
#+CAPTION: Adatap√ß√£o de [cite:@cesarini2016designing p.29 chap.2]
#+RESULTS: erlang-process
[[file:./img/erlang_process.png]]


** Message Passing (I)

#+CAPTION: Processo ~<0.42.0>~ enviando uma mensagem para a mailbox do processo ~<0.48.0>~. [cite:@hebert2013learn]
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/erlang_message_passing_01.png]]

** Message Passing (II)

***  :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

#+CAPTION: ~Pid 1~ enviando uma Mensagem
#+begin_src erlang
  Pid2 ! { hello, Pid1 }.
#+end_src

***  :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

#+CAPTION: ~Pid 2~ recebendo mensagens
#+begin_src erlang
  receive
      {hello, From} -> ...
      _ -> ...
  end.
#+end_src

*** :B_ignoreheading:
   :PROPERTIES:
   :BEAMER_env: ignoreheading
   :END:

#+NAME: erlang-message-passing-02
#+BEGIN_SRC dot :file ./img/erlang_message_passing_02.png :cmdline -Kdot -Tpng :exports results
  digraph Send {
    node [shape=circle];
    rankdir="LR";

    pid1 [label="Pid 1\n<0.42.0>", xlabel="Pid2 ! { hello, self() }", fontsize="10pt", style=filled, fillcolor=grey];
    pid2 [label="Pid 2\n<0.48.0>", fontsize="10pt", style=filled, fillcolor=grey, xlabel="receive (...) end." ];

    pid1 -> pid2 [label="{ hello, Pid1 }", fontsize="10pt", style=dashed];
  }
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+RESULTS: erlang-message-passing-02
[[file:./img/erlang_message_passing_02.png]]

** Anatomia de um Processo

#+NAME: erlang-process-skeleton
#+BEGIN_SRC dot :file ./img/erlang_process_skeleton.png :cmdline -Kdot -Tpng :exports results
  digraph Process {
    node [fontsize="10pt", style=filled];
    
    start [label="Start", fillcolor=gray, shape=circle];
    stop [label="Stop", fillcolor=white, shape=circle];
    init [label="Initialize", xlabel="Mod:Func(Args)", fillcolor=yellow, shape=rectangle];
    loop [label="Receive/Eval Loop", fillcolor=green, shape=rectangle]
    terminate [label="Terminate", fillcolor=red, shape=rectangle];

    start -> init [label="  spawn(Mod, Func, Args)", fontsize="10pt", minlen=1];
    init -> loop
    loop -> loop
    stop -> loop
    loop -> terminate
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+CAPTION: [cite:@cesarini2016designing p.55 chap.3]
#+RESULTS: erlang-process-skeleton
[[file:./img/erlang_process_skeleton.png]]


** OTP (Open Telecom Platform)

#+CAPTION: OTP fornece padr√µes e ferramentas que simplificam sua vida e evitam complexidade desnecess√°ria causada por escolher ferramentas ruins. [cite:@cesarini2016designing p.4-5 chap.1].
#+ATTR_LATEX: :width 0.6\linewidth
[[./img/erlang_otp.png]]

** OTP Applications (I)

+ M√≥dulos: O n√≠vel mais baixo de encapsulamento.
+ Applications: Um agrupamento de m√≥dulos, n√≠vel intermedi√°rio.

#+CAPTION: Exemplo de uma "Library Application".
#+ATTR_LATEX: :width 0.8\linewidth
[[file:./img/erlang_otp_app_01.png]]

** OTP Applications (II)

+ Quando voc√™ implementa as fun√ß√µes ~start/2~ e ~stop/1~ (no behaviour ~application~),
  o OTP agora √© capaz de gerenciar o ciclo de vida de sua aplica√ß√£o de *forma padronizada*.
+ Este processo agora pode inicar outros processos.

#+CAPTION: Exemplo de uma "Application", que implementa ~start/2~ e ~stop/1~.
#+ATTR_LATEX: :width 0.8\linewidth
[[file:./img/erlang_otp_app_02.png]]

** OTP Supervisors

#+begin_quote
Uma √°rvore de supervis√£o √© uma √°rvore de processos. Os processos superiores 
(~supervisors~) na √°rvore monitoram os processos menores (~workers~) na hierarquia e
os reiniciam em caso de falhas.

[cite:@armstrong2013 p.398 chapter.23 part.23.5]
#+end_quote

#+NAME: fig:erlang-sup-callbacks
#+BEGIN_SRC dot :file ./img/erlang_sup_callbacks.png :cmdline -Kdot -Tpng :exports results
digraph gen_server {
  rankdir=LR;
  node [shape=box, style=filled];
  edge [dir=both];
  
  graph [margin=0.2];
  
  api [label="API\n\nstart_link/0\n(...)", 
        fillcolor=lightblue, 
        width=2, 
        height=1.5,
        fontsize=12];
  
  process [label="supervisor\nProcess", 
            shape=circle, 
            fillcolor=gray70,
            width=1.2,
            fontsize=11];
  
  callbacks [label="Callback Module\n\ninit/1", 
              fillcolor=lightcyan,
              width=2,
              height=1.5,
              fontsize=12];
  
  api -> process [arrowhead=normal, arrowtail=normal];
  process -> callbacks [arrowhead=normal, arrowtail=normal];
}
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+CAPTION: Adapta√ß√£o de [cite:@cesarini2016designing p.175 chap.8]
#+RESULTS: fig:erlang-sup-callbacks
[[file:./img/erlang_sup_callbacks.png]]

** Estrat√©gias de Supervis√£o (~one_for_one~)

+ Se um processo monitorado morre, deve ser reiniciado.

    #+NAME: fig:erlang-supervisor-o4o
    #+BEGIN_SRC dot :file ./img/erlang_supervisor_o4o.png :cmdline -Kdot -Tpng :exports results
    graph g {
      ratio=fill
      splines=spline
      overlap=scale

      node [
        label="", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
      ]

      sup [label="S", pos="1,1", fillcolor="lightblue"]
      w1 [pos="0,0"]
      w2 [pos="0,1"]
      w3 [label="üî•", pos="0,2"]
      w4 [pos="0,3"]

      sup -- w1
      sup -- w2
      sup -- w3
      sup -- w4
    }
    #+END_SRC

    #+ATTR_LATEX: :width 0.4\linewidth
    #+RESULTS: fig:erlang-supervisor-o4o
    [[file:./img/erlang_supervisor_o4o.png]]

** Estrat√©gias de Supervis√£o (~one_for_one~)

+ Se um processo monitorado morre, deve ser reiniciado.

    #+NAME: fig:erlang-supervisor-o4o-2
    #+BEGIN_SRC dot :file ./img/erlang_supervisor_o4o_2.png :cmdline -Kdot -Tpng :exports results
    graph g {
      ratio=fill
      splines=spline
      overlap=scale

      node [
        label="", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
      ]

      sup [label="S", pos="1,1", fillcolor="lightblue"]
      w1 [pos="0,0"]
      w2 [pos="0,1"]
      w3 [label="‚ü≥", pos="0,2"]
      w4 [pos="0,3"]

      sup -- w1
      sup -- w2
      sup -- w3
      sup -- w4
    }
    #+END_SRC

    #+ATTR_LATEX: :width 0.4\linewidth
    #+RESULTS: fig:erlang-supervisor-o4o-2
    [[file:./img/erlang_supervisor_o4o_2.png]]

** Estrat√©gias de Supervis√£o (~one_for_all~)

+ Se um processo monitorado morre, todos os processos adjacentes devem ser
  reiniciados (incluindo o processo com erros).

    #+NAME: fig:erlang-supervisor-o4a
    #+BEGIN_SRC dot :file ./img/erlang_supervisor_o4a.png :cmdline -Kdot -Tpng :exports results
    graph g {
      ratio=fill
      splines=spline
      overlap=scale

      node [
        label="", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
      ]

      sup [label="S", pos="1,1", fillcolor="lightblue"]
      w1 [pos="0,0"]
      w2 [pos="0,1"]
      w3 [label="üî•", pos="0,2"]
      w4 [pos="0,3"]

      sup -- w1
      sup -- w2
      sup -- w3
      sup -- w4
    }
    #+END_SRC

    #+ATTR_LATEX: :width 0.4\linewidth
    #+RESULTS: fig:erlang-supervisor-o4a
    [[file:./img/erlang_supervisor_o4a.png]]

** Estrat√©gias de Supervis√£o (~one_for_all~)

+ Se um processo monitorado morre, todos os processos adjacentes devem ser
  reiniciados (incluindo o processo com erros).

    #+NAME: fig:erlang-supervisor-o4a-2
    #+BEGIN_SRC dot :file ./img/erlang_supervisor_o4a_2.png :cmdline -Kdot -Tpng :exports results
    graph g {
      ratio=fill
      splines=spline
      overlap=scale

      node [
        label="‚ü≥", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
      ]

      sup [label="S", pos="1,1", fillcolor="lightblue"]
      w1 [pos="0,0"]
      w2 [pos="0,1"]
      w3 [pos="0,2"]
      w4 [pos="0,3"]

      sup -- w1
      sup -- w2
      sup -- w3
      sup -- w4
    }
    #+END_SRC

    #+ATTR_LATEX: :width 0.4\linewidth
    #+RESULTS: fig:erlang-supervisor-o4a-2
    [[file:./img/erlang_supervisor_o4a_2.png]]

** ~gen_server~ (I)

+ Fornece uma interface para implementar processos que respondem a requisi√ß√µes
  s√≠ncronas (~call~) e ass√≠ncronas (~cast~).

#+NAME: fig:erlang-client-server
#+BEGIN_SRC dot :file ./img/erlang-client-server.png :cmdline -Kneato -Tpng :exports results
digraph client_server {
    rankdir=LR;
    node [shape=circle, label="", style=filled, fillcolor=white, width=0.8];
    edge [fontsize=10, width=0.5];
    
    // Clients
    client1 [xlabel="Client 1", pos="0,2!"];
    client2 [xlabel="Client 2", pos="0,1!"];  
    client3 [xlabel="Client 3", pos="0,0!"];
    
    // Server
    server [xlabel="Server", pos="4,1!"];
        
    // Query/Reply arrows
    client1 -> server [style=solid];
    client2 -> server [style=solid];
    client3 -> server [style=solid];
     
    server -> client1 [style=dashed];
    server -> client2 [style=dashed];
    server -> client3 [style=dashed];
}
#+END_SRC

#+ATTR_LATEX: :width 0.7\linewidth
#+RESULTS: fig:erlang-client-server
[[file:./img/erlang-client-server.png]]

** ~gen_server~ (II)

+ Gerenciamento de ciclo de vida padronizado: inicializa√ß√£o e outras transi√ß√µes
  de estado s√£o feitas de forma consistente.
+ Podem ser facilmente integrados em √°rvores de supervis√£o.

#+NAME: fig:erlang-gen_server
#+BEGIN_SRC dot :file ./img/erlang-gen_server.png :cmdline -Kdot -Tpng :exports results
digraph gen_server {
  rankdir=LR;
  node [shape=box, style=filled];
  edge [dir=both];
  
  graph [margin=0.2];
  
  api [label="API\n\nstart_link()\n(...)", 
        fillcolor=lightblue, 
        width=2, 
        height=1.5,
        fontsize=12];
  
  process [label="gen_server\nProcess", 
            shape=circle, 
            fillcolor=gray70,
            width=1.2,
            fontsize=11];
  
  callbacks [label="Callback Module\n\ninit/1\nhandle_call/3\nhandle_cast/2\nterminate/2", 
              fillcolor=lightcyan,
              width=2,
              height=1.5,
              fontsize=12];
  
  api -> process [arrowhead=normal, arrowtail=normal];
  process -> callbacks [arrowhead=normal, arrowtail=normal];
}
#+END_SRC

#+ATTR_LATEX: :width 0.7\linewidth
#+CAPTION: Adapta√ß√£o de [cite:@cesarini2016designing p.58 chapter.3]
#+RESULTS: fig:erlang-gen_server
[[file:./img/erlang-gen_server.png]]

** Finite State Machines

#+NAME: fig:erlang-fsm
#+BEGIN_SRC dot :file ./img/erlang_fsm.png :cmdline -Kdot -Tpng :exports results
digraph PlayerFSM {
    rankdir=TD;
    node [shape=rectangle, style=filled, fillcolor=lightblue];
    edge [fontsize=10];
    
    // States
    start [shape=point];
    terminated [shape=doublecircle, fillcolor=gray];
    
    // Initial transition
    start -> list_characters [label="  init / send {ok, {Pid, Email}}"];
    
    subgraph cluster_logged_in {
        label="logged_in";
        style=filled;
        fillcolor=khaki;
        node [fillcolor=white];
        
        list_characters [label="List Player Characters"];
        logout_action [label="Logout / \n Deactivate"];
        joining_map_success [label="Join Map"]
        
        list_characters -> joining_map_success;
        list_characters -> logout_action;
    }
    
    // in_game cluster
    subgraph cluster_in_game {
        label="in_game";
        style=filled;
        fillcolor=lightcoral;
        node [fillcolor=white];
        
        update_character [label="Update Character\n& Fetch Nearby Players"];
        harvest_resource [label="Harvest Resource"];
        exit_map_success [label="Deactivate Character"];
        exit_map_error [label="Exit Map (Error)"];
        
        harvest_resource -> update_character;
        update_character -> harvest_resource;
        update_character -> exit_map_success;
        update_character -> exit_map_error;
    }
    
    // Cross-cluster transitions
    joining_map_success -> update_character;
    exit_map_success -> list_characters;
    
    // Terminal transitions
    logout_action -> terminated;
    exit_map_error -> terminated;
}
#+END_SRC

#+ATTR_LATEX: :width 0.7\linewidth
#+RESULTS: fig:erlang-fsm
[[file:./img/erlang_fsm.png]]

** ~gen_statem~

+ Oferece uma interface para implementar m√°quinas de estados finitos com estados
  e transi√ß√µes bem definidos.

#+CAPTION: Cada jogador no Lyceum √© um processo com um ~gen_statem~.
#+ATTR_LATEX: :width 0.5\linewidth
[[./img/erlang_gen_statem.png]]

** Combinando as Estruturas (I)

#+NAME: erlang-app-structure
#+BEGIN_SRC dot :file ./img/erlang_app_structure.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="lightcoral"]
  sup [xlabel="Supervisor", pos="1,1", fillcolor="lightblue"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  w4 [label="P4", pos="0,3"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
  sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+CAPTION: Arquitetura est√°tica com 1 ~application~ que inicia um ~supervisor~, que monitora *exatamente* 4 processos.
#+RESULTS: erlang-app-structure
[[file:./img/erlang_app_structure.png]]

** Combinando as Estruturas (II)

#+NAME: erlang-app-structure-ii
#+BEGIN_SRC dot :file ./img/erlang_app_structure_ii.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="lightcoral"]
  sup [xlabel="Top Level Supervisor", pos="1,1", fillcolor="lightblue"]
  isup [xlabel="Inner Supervisor", pos="0,0", fillcolor="lightblue"]
  
  iw1 [label="P1", pos="0,1"]
  iw2 [label="P2", pos="0,1"]
  w2 [label="P3", pos="0,1"]
  w3 [label="P4", pos="0,2"]
  w4 [label="P5", pos="0,3"]
  
  app -- sup
  sup -- isup
  isup -- iw1
  isup -- iw2
  sup -- w2
  sup -- w3
  sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+CAPTION: Arquitetura est√°tica com 1 ~application~ que inicia 1 ~top level supervisor~, que monitora *exatamente* 1 ~supervisor~ interno e 3 outros *worker processes*. O ~supervisor~ interno monitora exatamente 2 outros processos.
#+RESULTS: erlang-app-structure-ii
[[file:./img/erlang_app_structure_ii.png]]

** Combinando as Estruturas (III)

#+NAME: erlang-app-structure-iii-1
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iii_1.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="lightcoral"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="khaki"]

  app -- sup
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+CAPTION: Arquitetura din√¢mica com 1 ~application~ que inicia 1 ~supervisor~ din√¢mico, monitorando 0 processos.
#+RESULTS: erlang-app-structure-iii-1
[[file:./img/erlang_app_structure_iii_1.png]]

** Combinando as Estruturas (III)

#+NAME: erlang-app-structure-iii-2
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iii_2.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="lightcoral"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="khaki"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+CAPTION: Arquitetura din√¢mica com 1 ~application~ e 1 ~supervisor~ din√¢mico, monitorando 3 processos.
#+RESULTS: erlang-app-structure-iii-2
[[file:./img/erlang_app_structure_iii_2.png]]

** Combinando as Estruturas (IV)

#+NAME: erlang-app-structure-iv
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iv.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="lightcoral"]
  sup1 [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="khaki"]
  sup2 [pos="1,2", fillcolor="lightblue"]
  sup3 [pos="1,3", fillcolor="lightblue"]
  sup4 [pos="1,4", fillcolor="khaki"]
  sup5 [pos="1,5", fillcolor="khaki"]

  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]

  w4 [label="P4", pos="0,3"]
  w5 [label="P5", pos="0,4"]

  w6 [label="P6", pos="0,5"]
  w7 [label="P7", pos="0,6"]

  w8 [label="P8", pos="0,7"]
  w9 [label="P9", pos="0,8"]
  
  app -- sup1
  app -- sup2
  app -- sup3
  sup1 -- w1
  sup1 -- w2
  sup1 -- w3

  sup2 -- w4
  sup2 -- w5

  sup3 -- sup4
  sup3 -- sup5

  sup4 -- w6
  sup4 -- w7

  sup5 -- w8
  sup5 -- w9
}
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+RESULTS: erlang-app-structure-iv
[[file:./img/erlang_app_structure_iv.png]]

** Recaptulando

+ M√≥dulos: O n√≠vel mais baixo de encapsulamento.
+ ~Applications~: Um agrupamento de m√≥dulos, n√≠vel intermedi√°rio.

#+NAME: erlang-application-versioning
#+BEGIN_SRC dot :file ./img/erlang_application_versioning.png :cmdline -Kdot -Tpng :exports results
graph Release {
  ratio=fill
  splines=spline
  overlap=scale

  subgraph cluster_application {
    label="App v1.2.3"
    
    node [
      label="", 
      xlabel="",
      shape=circle,
      fixedsize=true,
      width=0.3,
      color="black",
      fillcolor="ghostwhite",
      style="filled,solid",
      fontsize=12
    ]
    
    app [pos="1,1", fillcolor="lightcoral"]
    sup1 [pos="1,1", fillcolor="khaki"]
    sup2 [pos="1,2", fillcolor="lightblue"]
    sup3 [pos="1,3", fillcolor="lightblue"]
    sup4 [pos="1,4", fillcolor="khaki"]
    sup5 [pos="1,5", fillcolor="khaki"]

    w1 [label="P1", pos="0,0"]
    w2 [label="P2", pos="0,1"]
    w3 [label="P3", pos="0,2"]

    w4 [label="P4", pos="0,3"]
    w5 [label="P5", pos="0,4"]

    w6 [label="P6", pos="0,5"]
    w7 [label="P7", pos="0,6"]

    w8 [label="P8", pos="0,7"]
    w9 [label="P9", pos="0,8"]
    
    app -- sup1
    app -- sup2
    app -- sup3
    sup1 -- w1
    sup1 -- w2
    sup1 -- w3

    sup2 -- w4
    sup2 -- w5

    sup3 -- sup4
    sup3 -- sup5

    sup4 -- w6
    sup4 -- w7

    sup5 -- w8
    sup5 -- w9
  }
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-application-versioning
[[file:./img/erlang_application_versioning.png]]

** Releases

+ M√≥dulos: O n√≠vel mais baixo de encapsulamento.
+ ~Applications~: Um agrupamento de m√≥dulos, n√≠vel intermedi√°rio.
+ ~Releases~: Um agrupamento de uma ou mais aplica√ß√µes.

#+NAME: erlang-release
#+BEGIN_SRC dot :file ./img/erlang_release.png :cmdline -Kdot -Tpng :exports results
graph Release {
  ratio=fill
  splines=spline
  overlap=scale

  subgraph cluster_rel {
    label="Release v2.4.7"
    subgraph cluster_application {
      label="App v1.2.3"
      
      node [
        label="", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="ghostwhite",
        style="filled,solid",
        fontsize=12
      ]
      
      app [pos="1,1", fillcolor="lightcoral"]
      sup1 [pos="1,1", fillcolor="khaki"]
      sup2 [pos="1,2", fillcolor="lightblue"]
      sup3 [pos="1,3", fillcolor="lightblue"]
      sup4 [pos="1,4", fillcolor="khaki"]
      sup5 [pos="1,5", fillcolor="khaki"]

      w1 [label="P1", pos="0,0"]
      w2 [label="P2", pos="0,1"]
      w3 [label="P3", pos="0,2"]

      w4 [label="P4", pos="0,3"]
      w5 [label="P5", pos="0,4"]

      w6 [label="P6", pos="0,5"]
      w7 [label="P7", pos="0,6"]

      w8 [label="P8", pos="0,7"]
      w9 [label="P9", pos="0,8"]
      
      app -- sup1
      app -- sup2
      app -- sup3
      sup1 -- w1
      sup1 -- w2
      sup1 -- w3

      sup2 -- w4
      sup2 -- w5

      sup3 -- sup4
      sup3 -- sup5

      sup4 -- w6
      sup4 -- w7

      sup5 -- w8
      sup5 -- w9
    }
  }
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-release
[[file:./img/erlang_release.png]]

** Umbrellas

#+NAME: erlang-umbrella
#+BEGIN_SRC dot :file ./img/erlang_umbrella.png :cmdline -Kdot -Tpng :exports results
digraph ServerUmbrella {
  rankdir=TB;
  compound=true;
  newrank=true;
  splines=ortho;
  
  node [shape=box, style=filled, fontname="Arial", fontsize=10, fontcolor=black];
  edge [fontname="Arial", fontsize=5, color="#374151"];
  
  // Umbrella Subgraph
  subgraph cluster_server {
    label="Server Umbrella";
    style=filled;
    fillcolor="#f8fafc";
    color="#0f172a";
    penwidth=4;
    fontcolor="#0f172a";
    fontsize=14;
    
    subgraph cluster_auth {
      label="Auth";
      style=filled;
      fillcolor="#dbeafe";
      color="#1e40af";
      penwidth=3;
      fontsize=12;
      
      AA [label="Auth Application", fillcolor="lightcoral"];
      AS [label="Auth Supervisor", fillcolor="lightblue"];
      SAW [label="Simple Auth Worker", fillcolor="ghostwhite"];

      AA -> AS;
      AS -> SAW;
    }
    
    subgraph cluster_world {
      label="World";
      style=filled;
      fillcolor="#dcfce7";
      color="#16a34a";
      penwidth=3;
      fontsize=12;
      
      WA [label="World Application", fillcolor="lightcoral"];
      WS [label="World Supervisor", fillcolor="lightblue"];
      WM [label="World Migrations", fillcolor="ghostwhite"];
      WM1 [label="Map 1", fillcolor="ghostwhite"];

      WA -> WS;
      WS -> WM1;
      WS -> WM;
    }
    
    subgraph cluster_player {
      label="Player";
      style=filled;
      fillcolor="#fed7aa";
      color="#ea580c";
      penwidth=3;
      fontsize=12;
      
      PA [label="Player Application", fillcolor="lightcoral"];
      TPLS [label="Top-Level Supervisor", fillcolor="lightblue"];
      DPS1 [label="Dynamic Supervisor", fillcolor="khaki"];
      DPS2 [label="Dynamic Supervisor", fillcolor="khaki"];
      DPS3 [label="Dynamic Supervisor", fillcolor="khaki"];
      DPSN [label="Dynamic Supervisor", fillcolor="khaki"];

      P1 [label="Player 1", fillcolor="ghostwhite"];
      P2 [label="Player 2", fillcolor="ghostwhite"];
      P3 [label="Player 3", fillcolor="ghostwhite"];
      PN [label="Player N", fillcolor="ghostwhite"];

      PA -> TPLS;
  
      TPLS -> DPS1;
      DPS1 -> P1;

      TPLS -> DPS2;
      DPS2 -> P2;

      TPLS -> DPS3;
      DPS3 -> P3;

      TPLS -> DPSN;
      DPSN -> PN;
    }
    
    subgraph cluster_cache {
      label="Cache";
      style=filled;
      fillcolor="#f3e8ff";
      color="#9333ea";
      penwidth=3;
      fontsize=12;
      
      CA [label="Cache Application", fillcolor="lightcoral"];
      CS [label="Cache Supervisor", fillcolor="lightblue"];
      CW [label="Cache Worker", fillcolor="ghostwhite"];
      MNESIA [label="MNESIA", shape=cylinder, fillcolor="palegreen"];

      CA -> CS;
      CS -> CW;
      CW -> MNESIA [dir=both];
    }
    
    subgraph cluster_libraries {
      label="Utility Libraries";
      style=filled;
      fillcolor="#f1f5f9";
      color="#475569";
      penwidth=3;
      fontsize=12;
      fontname="Arial Bold";
      
      LPG [label="PostgreSQL Library", fillcolor="violet", style="filled,dashed"];
      LMAP [label="Map Library", fillcolor="violet", style="filled,dashed"];
    }
  }
}
#+END_SRC

#+CAPTION: Uma √∫nica "release", m√∫ltiplas aplica√ß√µes.
#+ATTR_LATEX: :width \linewidth
#+RESULTS: erlang-umbrella
[[file:./img/erlang_umbrella.png]]

** Arquitetura do Lyceum

#+NAME: lyceum-arch
#+BEGIN_SRC dot :file ./img/lyceum_arch.png :cmdline -Kdot -Tpng :exports results
digraph Lyceum {
  rankdir=TB;
  compound=true;
  newrank=true;
  splines=ortho;
  
  node [shape=box, style=filled, fontname="Arial", fontsize=10, fontcolor=black];
  edge [fontname="Arial", fontsize=5, color="#374151"];

  subgraph server_umbrella {
    // Umbrella Subgraph
    subgraph cluster_server {
      label="Server Umbrella";
      style=filled;
      fillcolor="#f8fafc";
      color="#0f172a";
      penwidth=4;
      fontcolor="#0f172a";
      fontsize=14;
      
      subgraph cluster_auth {
        label="Auth";
        style=filled;
        fillcolor="#dbeafe";
        color="#1e40af";
        penwidth=3;
        fontsize=12;
        
        AA [label="Auth Application", fillcolor="lightcoral"];
        AS [label="Auth Supervisor", fillcolor="lightblue"];
        SAW [label="Simple Auth Worker", fillcolor="ghostwhite"];
  
        AA -> AS;
        AS -> SAW;
      }
      
      subgraph cluster_world {
        label="World";
        style=filled;
        fillcolor="#dcfce7";
        color="#16a34a";
        penwidth=3;
        fontsize=12;
        
        WA [label="World Application", fillcolor="lightcoral"];
        WS [label="World Supervisor", fillcolor="lightblue"];
        WM [label="World Migrations", fillcolor="ghostwhite"];
        WM1 [label="Map 1", fillcolor="ghostwhite"];
  
        WA -> WS;
        WS -> WM1;
        WS -> WM;
      }
      
      subgraph cluster_player {
        label="Player";
        style=filled;
        fillcolor="#fed7aa";
        color="#ea580c";
        penwidth=3;
        fontsize=12;
        
        PA [label="Player Application", fillcolor="lightcoral"];
        TPLS [label="Top-Level Supervisor", fillcolor="lightblue"];
        DPS1 [label="Dynamic Supervisor", fillcolor="khaki"];
        DPS2 [label="Dynamic Supervisor", fillcolor="khaki"];
        DPS3 [label="Dynamic Supervisor", fillcolor="khaki"];
        DPSN [label="Dynamic Supervisor", fillcolor="khaki"];
  
        P1 [label="Player 1", fillcolor="ghostwhite"];
        P2 [label="Player 2", fillcolor="ghostwhite"];
        P3 [label="Player 3", fillcolor="ghostwhite"];
        PN [label="Player N", fillcolor="ghostwhite"];
  
        PA -> TPLS;
    
        TPLS -> DPS1;
        DPS1 -> P1;
  
        TPLS -> DPS2;
        DPS2 -> P2;
  
        TPLS -> DPS3;
        DPS3 -> P3;
  
        TPLS -> DPSN;
        DPSN -> PN;
      }
      
      subgraph cluster_cache {
        label="Cache";
        style=filled;
        fillcolor="#f3e8ff";
        color="#9333ea";
        penwidth=3;
        fontsize=12;
        
        CA [label="Cache Application", fillcolor="lightcoral"];
        CS [label="Cache Supervisor", fillcolor="lightblue"];
        CW [label="Cache Worker", fillcolor="ghostwhite"];
        MNESIA [label="MNESIA", shape=cylinder, fillcolor="palegreen"];
  
        CA -> CS;
        CS -> CW;
        CW -> MNESIA [dir=both];
      }
      
      subgraph cluster_libraries {
        label="Utility Libraries";
        style=filled;
        fillcolor="#f1f5f9";
        color="#475569";
        penwidth=3;
        fontsize=12;
        fontname="Arial Bold";
        
        LPG [label="PostgreSQL Library", fillcolor="violet", style="filled,dashed"];
        LMAP [label="Map Library", fillcolor="violet", style="filled,dashed"];
      }
    }
  }

  subgraph cluster_client_1 {
    label="";
    style=filled;
    fillcolor="lightgoldenrodyellow";
    color="gold";
    penwidth=3;
    fontsize=12;
 
    Z1 [label="Zerl", fillcolor="plum"];
    C1 [label="Client 1", fillcolor="ghostwhite"];

    Z1 -> C1;
    C1 -> Z1;
    P1 -> Z1;
    Z1 -> P1;
  }

  subgraph cluster_client_2 {
    label="";
    style=filled;
    fillcolor="lightgoldenrodyellow";
    color="gold";
    penwidth=3;
    fontsize=12;

    Z2 [label="Zerl", fillcolor="plum"];
    C2 [label="Client 2", fillcolor="ghostwhite"];

    Z2 -> C2;
    C2 -> Z2;
    P2 -> Z2;
    Z2 -> P2;
  }

  subgraph cluster_client_3 {
    label="";
    style=filled;
    fillcolor="lightgoldenrodyellow";
    color="gold";
    penwidth=3;
    fontsize=12;

    Z3 [label="Zerl", fillcolor="plum"];
    C3 [label="Client 3", fillcolor="ghostwhite"];

    Z3 -> C3;
    C3 -> Z3;
    P3 -> Z3;
    Z3 -> P3;
  }

  subgraph cluster_client_n {
    label="";
    style=filled;
    fillcolor="lightgoldenrodyellow";
    color="gold";
    penwidth=3;
    fontsize=12;

    subgraph player_2 {  
      ZN [label="Zerl", fillcolor="plum"];
      CN [label="Client N", fillcolor="ghostwhite"];

      ZN -> CN;
      CN -> ZN;
      PN -> ZN;
      ZN -> PN;
    }
  }
}
#+END_SRC

#+CAPTION: A biblioteca "zerl" funciona como uma ponte entre o cliente Zig e a release em Erlang.
#+ATTR_LATEX: :width \linewidth
#+RESULTS: lyceum-arch
[[file:./img/lyceum_arch.png]]

* PostgreSQL

** Schemas + Views como M√≥dulos

+ Os ~schemas~ do PostgreSQL s√£o usados ‚Äã‚Äãcomo ~namespaces~.
+ Cada ~schema~ cont√©m tabelas internas que n√£o s√£o acessadas diretamente.
+ O server em Erlang interage exclusivamente com as views.

#+NAME: posgtresql-schemas
#+BEGIN_SRC dot :file ./img/postgresql_schemas.png :cmdline -Kdot -Tpng :exports results
digraph g {
    graph [splines=true, rankdir=td];

    subgraph cluster_pg {
        label="lyceum"
        bgcolor="azure"

        subgraph cluster_sc {
            label="schema:character";
            bgcolor="aquamarine"

            subgraph cluster_ct {
                label="\ntables";
                style=filled;
                color=lightgray;

                c_instance [label="instance"; shape=box];
                c_stats [label="stats"; shape=box];
                c_position [label="position"; shape=box];
                c_active [label="active"; shape=box];
                c_item [label="item"; shape=box];
                c_inventory [label="inventory"; shape=box];
            }

            character_view [label="character.view", shape=square, style=filled, fillcolor=lightblue];
            character_view -> c_instance;
            character_view -> c_stats;
            character_view -> c_position;
        }


        subgraph cluster_sm {
            label="schema:map";
            bgcolor="aquamarine"

            subgraph cluster_mt {
                label="\ntables";
                style=filled;
                color=lightgray;

                m_instance [label="instance"; shape=box];
                m_tile [label="tile"; shape=box];
                m_object [label="object"; shape=box];
                m_object_is_resource [label="object_is_resource"; shape=box];
                m_resource [label="resource"; shape=box];
            }

            map_resource_item_view [label="map.resource_item_view", shape=square, style=filled, fillcolor=lightblue];
            map_resource_view [label="map.resource_view", shape=square, style=filled, fillcolor=lightblue];

            map_resource_item_view -> c_item;
            map_resource_item_view -> c_inventory;
            map_resource_item_view -> c_instance;
            map_resource_item_view -> m_object_is_resource;

            map_resource_view -> m_object;
            map_resource_view -> m_object_is_resource;
            map_resource_view -> m_resource;
        }
    }
}
#+END_SRC

#+ATTR_LATEX: :width \linewidth
#+RESULTS: posgtresql-schemas
[[file:./img/postgresql_schemas.png]]

** Updatable Views

#+CAPTION: A ~character.view~ acaba operando como um m√≥dulo, sem expor detalhes de implemeta√ß√£o das tabelas originais.
#+NAME: fig:sql-updatable-view
#+ATTR_LATEX: :width 0.7\linewidth
[[./img/sql_updatable_views.png]]

** Constraints

#+CAPTION: Garantindo que um equipamento est√° sendo usado da forma correta.
#+NAME: fig:sql-checks
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/sql_checks.png]]

** Omnigres (I)

+ Omnigres √© uma extens√£o do PostgreSQL que adiciona suporte integrado a
  HTTP/WebSockets, roteamento e consultas reativas.
+ Inclui m√≥dulos avan√ßados como ~omni_httpd~, ~omni_session~, ~omni_vfs~, ~omni_types~,
  ~omni_ledger~, entre outros.

** Omnigres (II)

#+CAPTION: Como ter sum types em PostgreSQL
#+NAME: fig:sql-omnigres-du
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/sql_omnigres_du.png]]


* Nix

** Como montar o ambiente de desenvolvimento?

+ Zig
+ Erlang
+ PostgreSQL (com extens√µes)

** Como modelar depend√™ncias

#+begin_src shell 
  nix-store --query \
    --graph $(readlink -f $(which python)) > python.dot
  dot -Tps python.dot -o img/nix_python.png
  rm python.dot
#+end_src

#+CAPTION: Todas as depend√™ncias necess√°rias para rodar o interpretador do Python 3.13 
#+ATTR_LATEX: :width \linewidth
[[./img/nix_python.png]]

** O que √© Nix?

#+ATTR_LATEX: :width 0.7\linewidth
[[./img/nix_the_declarative_trinity.png]]

** Nix (Linguagem)

Nix √© uma linguagem de programa√ß√£o pura, funcional, /lazy/, declarativa e reproduz√≠vel.

#+begin_quote
Reprodutibilidade √© um conceito de design de software, onde uma opera√ß√£o para as
mesmas entradas produz a mesma sa√≠da.
#+end_quote

** Nix (Gerenciador de pacotes)

#+ATTR_BEAMER: :overlay +-
+ ~nix~ √© um gerenciador de pacotes puramente funcional.
+ Trata pacotes como *valores* em linguagens de programa√ß√£o puramente funcionais.
+ Sempre compila todo o /fecho transitivo/ (ou √°rvore de depend√™ncias) de um
  pacote, por√©m, se uma depend√™ncia j√° estiver presente na ~/nix/store/~ (ou num
  cache remoto), o ~nix~ pode us√°-la, o que significa que pode fornecer
  compila√ß√µes incrementais.

** Nixpkgs

#+CAPTION: Fonte: [[https://repology.org/repositories/graphs][Repology]] 
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/nix_repology.png]]

** Nix Store (I)
:PROPERTIES:
:BEAMER_envargs: [allowframebreaks]
:END:

#+ATTR_BEAMER: :overlay +-
+ Armazenamento imut√°vel: Todos os pacotes, configura√ß√µes e depend√™ncias residem
  na ~/nix/store~ de forma ~read-only~, com caminhos derivados a partir de um hash
  criptogr√°fico:

#+begin_src 
/nix/store/b6gvzjyb2pg(...)54ad73z-firefox-33.1
|---------||----------------------||-----------|
  store             digest             name
#+end_src

+ Cada caminho na ~/nix/store/~ inclui um hash computado a partir de toda a
  deriva√ß√£o do pacote (c√≥digo-fonte, depend√™ncias, configura√ß√µes de compila√ß√£o,
  ambiente).

** Nix Store (II)
:PROPERTIES:
:BEAMER_envargs: [allowframebreaks]
:END:

#+ATTR_BEAMER: :overlay +-
+ Garbage collection: Pacotes antigos ou n√£o utilizados permanecem at√© serem
  explicitamente removidos com ~nix-collect-garbage~.

+ Sustenta o modelo funcional de gerenciamento de pacotes do Nix, permitindo
  *compila√ß√µes reproduz√≠veis*, *atualiza√ß√µes at√¥micas* e *rollbacks*.

    #+CAPTION: Fonte [cite: @dolstra2004nix p.6].
    #+ATTR_LATEX: :width 0.35\linewidth
    [[./img/nix_store.png]]

** Gera√ß√µes (e rollbacks)

#+ATTR_LATEX: :width 0.8\linewidth
#+CAPTION: Fonte: [[https://nixos.org/guides/how-nix-works/][How NixOS works]] 
[[./img/nix_generations.png]]

** NixOS = Linux + FP

#+ATTR_LATEX: :width 0.8\linewidth
[[./img/nixos_logo.png]]

+ Distribui√ß√£o GNU/Linux, completamente configur√°vel e gerenci√°vel via Nix
  (linguagem) e ~nix~ (gerenciador de pacotes).
+ /Infrastructure as code/ desde 2003.
+ O estado do sistema √© uma sa√≠da de tudo que est√° sua configura√ß√£o (em Nix).

** Nix n√£o √© Docker :noexport:
#+BEGIN_QUOTE
"Mas n√≥s j√° temos o Docker..."
#+END_QUOTE

#+ATTR_BEAMER: :overlay +-
+ Num ~Dockerfile~, voc√™ tem garantias de que um *mesmo comando* vai ser rodado na
  *mesma ordem*, ou seja:
  * Isso n√£o significa que voc√™ vai ter o mesmo resultado *sempre*.
  * *Repetibilidade* n√£o √© *reprodutibilidade*.

** Nix Shells (I)

#+begin_src shell
  $ hello
  hello: command not found
  $ nix shell nixpkgs#hello nixpkgs#cowsay
  $ hello
  Hello, world!
  $ cowsay "Hello, world!"
   _______________
  < Hello, world! >
   ---------------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
#+end_src
#+CAPTION: Fonte:[[https://nixos-and-flakes.thiscute.world/development/intro#creating-a-custom-shell-environment-with-nix-shell][NixOS and Flakes book]] 

** Nix Shells (II)

#+CAPTION: A primeira demo, com o benchmark em Erlang, rodou numa ~nix shell~.
#+begin_src shell
  #!/usr/bin/env nix
  #! nix shell nixpkgs#erlang --command bash

  erlc benchmark.erl
  erl -noshell -s benchmark start 1000000 -s init stop
#+end_src

** Devenv (I)

#+ATTR_BEAMER: :overlay +-
+ Para desenvolvimento local, usamos uma combina√ß√£o de Nix Shells e [[https://devenv.s/h][devenv.sh]]
+ M√≥dulos para servi√ßos populares como PostgreSQL, Redis, MySQL, RabbitMQ, etc.
+ Acesso a todos pacotes do [[https://search.nixos.org/packages?channel=unstable&][nixpkgs]] (atualmente mais the 120K).

    #+ATTR_LATEX: :width 0.42\linewidth
    [[./img/nix_devenv.png]]

** Devenv (II)

#+CAPTION: Configura√ß√£o declarativa do PostgreSQL (com extens√µes).
#+ATTR_LATEX: :width 0.5\linewidth
[[./img/nix_postgresql.png]]

** Devenv (Demo #2)

#+begin_src shell
  cd lyceum
  nix develop --impure
#+end_src

ou, se voc√™ estiver usando [[https://github.com/direnv/direnv][direnv]] (com [[https://github.com/nix-community/nix-direnv][nix-direnv]])

#+begin_src shell
  cd lyceum
#+end_src

seguindo dos seguintes comandos (em shells diferentes):

#+begin_src shell
  devenv up
  server
  client-release
#+end_src

** OCI Images (Bonus)

#+begin_src shell
  # OCI Image
  nix build .#dockerImage
  docker load < ./result
  docker container run --network=host lyceum:latest
#+end_src


* NixOS

** Servidor NixOS Declarativo

+ O deploy do jogo √© feito num projeto separado, o [[https://github.com/dont-rely-on-nulls/chessboard][Chessboard]].
+ O provisionamento da infra inicial √© feito com [[https://opentofu.org/][Open Tofu]] e [[https://github.com/nix-community/nixos-anywhere/tree/main/terraform][nixos-anywhere]].
+ O processo pode ser replicado em 3 ambientes diferentes:
  * AWS e Magalu Cloud.
  * Localmente, criando uma VM QEMU automaticamente com Nix.

#+NAME: nixos-tofu
#+BEGIN_SRC dot :file ./img/nixos_tofu.png :cmdline -Kdot -Tpng :exports results
digraph OpenTofu {
    rankdir=LR;
    fontsize=20;


    subgraph cluster_tofu {
        label="Open Tofu";
        labelloc="t";
        bgcolor="cornsilk"

        subgraph cluster_stage1 {
            label="Stage 1: Bootstrap";
            bgcolor="aquamarine";

            vm [label="VM + Networking\nprovisioning", shape=box, style=filled, fillcolor="azure"];
            nixos_anywhere [label="NixOS Anywhere\n(Terraform Modules)", shape=box, style=filled, fillcolor="azure"];
            initial [label="Initial NixOS\n(minimal system)", shape=box, style=filled, fillcolor="azure"];

            vm -> nixos_anywhere -> initial;
        }

        subgraph cluster_stage2 {
            label="Stage 2: Full Configuration";
            bgcolor="aquamarine";

            initial_mods [label="Initial Modules", shape=box, style=filled, fillcolor="azure"];
            postgres [label="PostgreSQL", shape=box, style=filled, fillcolor="azure"];
            pgbouncer [label="pgbouncer", shape=box, style=filled, fillcolor="azure"];
            secrets [label="Secrets Management", shape=box, style=filled, fillcolor="azure"];
            lyceum [label="Lyceum", shape=box, style=filled, fillcolor="azure"];
        }

        initial -> initial_mods;
        initial -> postgres;
        initial -> pgbouncer;
        initial -> secrets;
        initial -> lyceum;
    }

}
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+RESULTS: nixos-tofu
[[file:./img/nixos_tofu.png]]

** NixOS Modules (I)

#+CAPTION: Exemplo de uma VM onde certos m√≥dulos s√£o habilitados
#+ATTR_LATEX: :width 0.45\linewidth
[[./img/nixos_modules_i.png]]
** NixOS Modules (II)

#+ATTR_LATEX: :width 0.5\linewidth
[[./img/nixos_modules_ii.png]]

** Particionamento declarativo com ~disko~

*** ~disko~                                                           :BMCOL:B_block:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :BEAMER_env: block
    :END:

O projeto [[https://github.com/nix-community/disko][disko]] possibilita o particionamento e formata√ß√£o de discos de forma
*declarativa*.

*** Exemplo                                                         :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.4
    :BEAMER_envargs: <2->
    :END:

#+ATTR_LATEX: :width 0.6\linewidth
[[./img/nixos_disko.png]]

** Um ~rm -rf /~ em todo Reboot

+ O [[https://github.com/nix-community/impermanence][impermanence]] √© outro m√≥dulo interessate da [[https://github.com/nix-community][nix-community]], que permite que
  apenas as parti√ß√µes e diret√≥rios descritas na configura√ß√£o em Nix sejam
  mantidas a cada reboot.
+ A inspira√ß√£o √© tentar tratar VMs como processos em Erlang.

#+ATTR_LATEX: :width 0.55\linewidth
[[./img/nixos_impermanence.png]]

** Compondo de forma Declarativa (e systemd)

#+NAME: lyceum-systemd
#+BEGIN_SRC dot :file ./img/lyceum_systemd.png :cmdline -Kdot -Tpng :exports results
digraph Lyceum {
  rankdir=TB;
  compound=true;
  newrank=true;
  splines=ortho;
  
  node [shape=box, style=filled, fontname="Arial", fontsize=10, fontcolor=black];
  edge [fontname="Arial", fontsize=5, color="#374151"];

  subgraph cluster_lyceum {
    label="Lyceum Repo";
    style=filled;
    fillcolor="#f8fafc";
    color="#0f172a";
    penwidth=4;
    fontcolor="#0f172a";
    fontsize=14;
    
    subgraph cluster_server {
      label="Server";
      style=filled;
      fillcolor="#dbeafe";
      color="#1e40af";
      penwidth=3;
      fontsize=12;
      
      SB [label="Pure Nix Build", fillcolor="lightcoral"];
    }
    
    subgraph cluster_cliet {
      label="Client";
      style=filled;
      fillcolor="#dcfce7";
      color="#16a34a";
      penwidth=3;
      fontsize=12;
      
      CB [label="Pure Nix Build", fillcolor="lightcoral"];
    }

    subgraph cluster_devshell {
      label="Devenv";
      style=filled;
      fillcolor="#fed7aa";
      color="#ea580c";
      penwidth=3;
      fontsize=12;
      
      DB [label="Nix Shell", fillcolor="lightcoral"];
    }
  }

  subgraph cluster_infra {
    label="Chessboard (Infra)";
    style=filled;
    fillcolor="lightgoldenrodyellow";
    color="gold";
    penwidth=3;
    fontsize=12;

    subgraph cluster_agenix {
      label="Agenix";
      style=filled;
      fillcolor="#f1f5f9";
      color="#475569";
      penwidth=3;
      fontsize=12;
      fontname="Arial Bold";
      
      S [label="Secrets", fillcolor="violet", style="filled,dashed"];
    }

    subgraph cluster_postgresql {
      label="PostgreSQL (systemd)";
      style=filled;
      fillcolor="#f1f5f9";
      color="#475569";
      penwidth=3;
      fontsize=12;
      fontname="Arial Bold";
      
      PG [label="PostgreSQL", fillcolor="violet", style="filled,dashed"];
      PGS [label="Unit Settings", fillcolor="violet", style="filled,dashed"];
      OS [label="Oneshot Script", fillcolor="violet", style="filled,dashed"];

      PGS -> PG
      OS -> PG [xlabel="Setup"]
    }
 
    subgraph cluster_lyceum_systemd {
      label="Lyceum Service (systemd)";
      style=filled;
      fillcolor="#f1f5f9";
      color="#475569";
      penwidth=3;
      fontsize=12;
      fontname="Arial Bold";
      
      LB [label="Server Binary", fillcolor="lightcoral", style="filled,dashed"];
      US [label="Unit Settings", fillcolor="violet", style="filled,dashed"];

      US -> LB
    }

    PG -> LB [xlabel="Requires"]
    S -> LB [xlabel="Requires"]
  }

  SB -> LB
}
#+END_SRC

#+CAPTION: O backend do jogo como um ~service~ do ~systemd~.
#+ATTR_LATEX: :width \linewidth
#+RESULTS: lyceum-systemd
[[file:./img/lyceum_systemd.png]]

** Mais PostgreSQL Declarativo

#+CAPTION: Inicializa√ß√£o declarativa do PostgreSQL (usando ~systemd~).
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/postgresql_nixos.png]]

** NixOS (Demo #3)

* Fim

:PROPERTIES:
:BEAMER_env: appendix
:END:

** Conclus√£o

#+ATTR_BEAMER: :overlay +-
+ Composi√ß√£o √© uma propriedade fundamental para alavancar at√© mesmo as ideias
  mais bizzaras.
  * APIs consistentes s√£o um plus.
+ Fundamenta√ß√£o te√≥rica s√≥lida tem um efeito multiplicador em termos de
  produtividade.
  * Programa√ß√£o declarativa √© naturalmente composicional.
+ Nix >>>>>>>> docker et al.


** Grupo de Estudos

*** Grupo :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

#+CAPTION: Grupo de estudos em Erlang/OTP.
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/erlang_study_group.jpg]]

*** Livro :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

#+ATTR_LATEX: :width 0.8\linewidth
[[./img/cesarini_book.jpg]]

** Perguntas?

*** Projetos
:PROPERTIES:
:BEAMER_ENV: block
:END:
- [[https://github.com/Dr-Nekoma/lyceum][Lyceum]]: Um jogo criado para testar todo tipo de ideia maluca.
- [[https://github.com/dont-rely-on-nulls/zerl][Zerl]]: Uma biblioteca que surgiu dentro do jogo e depois acabou virando algo maior.
- [[https://github.com/dont-rely-on-nulls/chessboard][Chessboard]]: O servidor NixOS declarativo.

*** Slides
:PROPERTIES:
:BEAMER_ENV: block
:END:
- [[https://github.com/dont-rely-on-nulls/gambiconf-2025][Gambiconf 2025]]: Uma "demo secreta", visto que todos os slides tamb√©m foram
  feitos num ambiente Nix com Emacs + Orgmode + LaTeX, cont√©m inclusive uma
  vers√£o customizada do Emacs para buildar os slides em CI.


** Bibliografia
  :PROPERTIES:
  :BEAMER_OPT: fragile,allowframebreaks,label=
  :END:      

#+print_bibliography:
