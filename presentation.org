#+STARTUP: inlineimages
#+TITLE: Criando um MMO-RPG
#+SUBTITLE: com Zig, Erlang, Nix e PostgreSQL
#+AUTHOR: Marcos Benevides
#+EMAIL: marcos.schonfinkel@gmail.com
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  pt
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_LINK_UP:
#+HTML_LINK_HOME:

#+startup: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+OPTIONS: H:2


* IntroduÃ§Ã£o

** Nekoma e Recreative Programming
+ Recreative programming (quickly explain what Nekoma is all about)

** The point where I joined the project.

+ There was already a lot of Zig, some Erlang code and postgresql as well.
+ We needed a way to somehow make that environment suck less.

* Nix Shells

+ Explain how Nix Shells made that happen and how we evolved the local dev
  environment to be bizarrely productive. Explain why Nix is better than Docker.

** O que Ã© Nix?

** Nixpkgs

** NixOS

** Nix Shell

** Nix nÃ£o Ã© Docker

** Devenv

** Escada de AbstraÃ§Ãµes

* Zig

** Erlang Interface

** C Nodes

** Zerl is Born

** Func Prog Sweden 2024

- [[https://www.youtube.com/watch?v=ejYcWRERetM][Zerl: Making Zig in the BEAM an ez time]] by Eduardo Lemos.

* Erlang

** Anatomia de um Processo

#+NAME: erlang-process-skeleton
#+BEGIN_SRC dot :file ./img/erlang_process_skeleton.png :cmdline -Kdot -Tpng :exports results
  digraph Process {
    node [fontsize="10pt", style=filled];
    
    start [label="Start", fillcolor=gray, shape=circle];
    stop [label="Stop", fillcolor=red, shape=circle];
    init [label="Initialize", xlabel="Mod:Func(Args)", fillcolor=yellow, shape=rectangle];
    loop [label="Receive/Eval Loop", fillcolor=green, shape=rectangle]
    terminate [label="Terminate", fillcolor=yellow, shape=rectangle];

    start -> init [label="  Spawn(Mod, Func, Args)", fontsize="10pt", minlen=1];
    init -> loop
    loop -> loop
    stop -> loop
    loop -> terminate
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-process-skeleton
[[file:./img/erlang_process_skeleton.png]]

** Let it Crash \rightarrow Let it Heal

*** TODO Minor point about Erlang's Philosophy and how people misuderstand it

** OTP (I)
+ Open Telecom Platform

*** TODO Minor points about history and why people at Ericsoon came up with OTP
*** TODO Maybe reference this

#+BEGIN_QUOTE
OTP is a domain-independent set of frameworks, principles, and patterns that
guide and support the structure, design, implementation, and deployment of
Erlang systems. Using OTP in your projects will help you avoid *accidental
complexity: things that are difficult because you picked inadequate tools*.

OTP is said to consist of three building blocks that, when used together,
provide a solid approach to designing and developing systems in the problem
domain weâ€™ve just described. They are *Erlang* itself, *tools* and *libraries*, and a
set of *design principles*. [cite:@cesarini2016designing p.4]
#+END_QUOTE

** OTP Applications

*** TODO A construct that can start/stop processes
*** TODO Not really useful on his own, unless you combine with other OTP concepts

** OTP Supervisors

#+begin_quote
A supervision tree is a tree of processes. The upper processes (supervisors) in
the tree monitor the lower processes (workers) in the tree and restart the lower
processes if they fail. [cite:@armstrong2013 p.398]
#+end_quote

Independentemente do que os processos monitados faÃ§am, um supervisor funciona
sempre do mesmo modo e seu funcionao pode ser dividido em duas categorias:

+ Uma parte genÃ©rica que lida com a criaÃ§Ã£o, monitoramento e ~restart~ de
  processos filhos.
+ Uma especificaÃ§Ã£o de como os processos filhos devem ser iniciados e reiniciados.

** OTP Supervisors (~one_for_one~)

+ ~one_for_one~ :: Se um processo monitorado morre, deve ser reiniciado.

#+NAME: fig:erlang-supervisor-o4o
#+BEGIN_SRC dot :file ./img/erlang_supervisor_o4o.png :cmdline -Kdot -Tpng :exports results
  graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
        label="", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
  	]

  	sup [label="S", pos="1,1"]
  	w1 [pos="0,0"]
  	w2 [pos="0,1"]
  	w3 [label="ðŸ”¥", pos="0,2"]
  	w4 [pos="0,3"]

  	sup -- w1
  	sup -- w2
  	sup -- w3
  	sup -- w4
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: fig:erlang-supervisor-o4o
[[file:./img/erlang_supervisor_o4o.png]]

** OTP Supervisors (~one_for_all~)

+ ~one_for_all~ :: Se um processo monitorado morre, todos devem ser reiniciado.

#+NAME: fig:erlang-supervisor-o4a
#+BEGIN_SRC dot :file ./img/erlang_supervisor_o4a.png :cmdline -Kdot -Tpng :exports results
  graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
        label="âŸ³", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
  	]

  	sup [label="S", pos="1,1"]
  	w1 [pos="0,0"]
  	w2 [pos="0,1"]
  	w3 [label="ðŸ”¥", pos="0,2"]
  	w4 [pos="0,3"]

  	sup -- w1
  	sup -- w2
  	sup -- w3
  	sup -- w4
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: fig:erlang-supervisor-o4a
[[file:./img/erlang_supervisor_o4a.png]]

** ~gen_server~

#+begin_quote
Much of the work you think of as the core of a program - calculating results,
storing information, and preparing replies - will fit neatly into the ~gen_server~
behavior. It provides a core set of methods that let you set up a process,
respond to requests, end the process gracefully, and even pass state to a new
process if this one needs to be upgraded in place. [cite:@laurent2017 p.148]
#+end_quote

** ~gen_statem~

*** TODO Explain what this stands for
*** TODO Show the player FSM

** Combinando as Estruturas (I)

#+NAME: erlang-app-structure
#+BEGIN_SRC dot :file ./img/erlang_app_structure.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Supervisor", pos="1,1", fillcolor="blue"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  w4 [label="P4", pos="0,3"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
  sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure
[[file:./img/erlang_app_structure.png]]

** Combinando as Estruturas (II)

#+NAME: erlang-app-structure-ii
#+BEGIN_SRC dot :file ./img/erlang_app_structure_ii.png :cmdline -Kdot -Tpng :exports results
graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
  		label="", 
  		xlabel="",
  		shape=circle,
  		fixedsize=true,
  		width=0.3,
  		color="black",
  		fillcolor="white",
  		style="filled,solid",
  		fontsize=12
  	]

  	app [xlabel="Application", pos="1,1", fillcolor="red"]
  	sup [xlabel="Top Level Supervisor", pos="1,1", fillcolor="blue"]
  	isup [xlabel="Inner Supervisor", pos="0,0", fillcolor="blue"]
	
	iw1 [label="P1", pos="0,1"]
	iw2 [label="P2", pos="0,1"]
  	w2 [label="P3", pos="0,1"]
  	w3 [label="P4", pos="0,2"]
  	w4 [label="P5", pos="0,3"]

  	app -- sup
  	sup -- isup
	isup -- iw1
	isup -- iw2
  	sup -- w2
  	sup -- w3
  	sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-ii
[[file:./img/erlang_app_structure_ii.png]]

** Combinando as Estruturas (III)

#+NAME: erlang-app-structure-iii
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iii.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="blue"]

  app -- sup
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-iii
[[file:./img/erlang_app_structure_iii.png]]

** Combinando as Estruturas (IV)

#+NAME: erlang-app-structure-iv
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iv.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="blue"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-iv
[[file:./img/erlang_app_structure_iv.png]]

** OTP Releases

+ 

** Umbrellas

+ 

* PostgreSQL

** Omnigres

+ 

** Schemas

+ 

* The Deploy

** Servidor NixOS Declarativo

+ Finish up showing how we composed everything together and even deployed a
  NixOS server to run the game.
+ Re-iterate about the value of recreative programming.
  
** Demo

+ Re-iterate about the value of recreative programming.

