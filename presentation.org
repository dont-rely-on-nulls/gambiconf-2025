#+TITLE: Criando um "MMO-RPG"
#+SUBTITLE: com Zig, Erlang, Nix e PostgreSQL

:SETTINGS:
#+STARTUP: inlineimages
#+STARTUP: beamer
#+AUTHOR: Marcos Benevides [[https://schonfinkel.github.io/][(schonfinkel.github.io]])
#+EMAIL: marcos.schonfinkel@gmail.com
#+DATE: <2025-09-14 Sun> 
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  pt
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:https://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_LINK_UP:
#+HTML_LINK_HOME: https://github.com/dont-rely-on-nulls/gambiconf-2025

#+beamer_theme: SimplePlus
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [bigger]
#+LATEX_HEADER: \input{./tex/template.tex}
#+LATEX_HEADER: \usepackage[backend=bibtex]{biblatex}
#+LATEX_HEADER: \addbibresource{./references.bib}
#+LATEX_HEADER: \bibliographystyle{authordate1}
#+bibliography: references
:END:

* Introdu√ß√£o

** Programa√ß√£o Recreativa

#+ATTR_BEAMER: :overlay +-
+ [[https://github.com/Dr-Nekoma][Dr. Nekoma]]: Projeto dedicado √† programa√ß√£o recreativa e explora√ß√£o de t√≥picos
  nichados e sem influ√™ncias mainstream. Comumente se materializa na forma de
  projetos bizarros (praticidade question√°vel).

+ [[https://github.com/dont-rely-on-nulls][Dont Rely on Nulls]]: Uma iniciativa que se destina a empreendimentos mais
  s√©rios. Por via de regra, projetos do "Dr. Nekoma" que se tornem s√©rios acabam
  sendo migrados e aprimorados nessa organiza√ß√£o (i.e. [[https://github.com/dont-rely-on-nulls/zerl][Zerl]]).

** Contexto

#+ATTR_BEAMER: :overlay +-
+ Este √© um ambiente recreativo.
+ Temos toda a liberdade que n√£o nos √© permitida durante (a maioria) dos
  empregos de tempo integral.
+ Quais s√£o as coisas que sonhamos em ter?
+ Como podemos fazer isso acontecer?

** Miss√£o

O projeto deve ter as seguintes caracter√≠sticas:

#+ATTR_BEAMER: :overlay +-
1. Deve ser r√°pido (considerando que √© um jogo), mas sem precisar recorrer ao Rust.
2. Gr√°ficos f√°ceis sem a dor de cabe√ßa das APIs gr√°ficas.
3. Uma fonte √∫nica de verdade.
4. Server distribu√≠do e tolerante a falhas.
5. Ambiente de desenvolvimento reproduz√≠vel, isolado e declarativo, que assume
   apenas a exist√™ncia de algum editor de texto e 0 pacotes instalados
   globalmente. _Todos os componentes devem rodar localmente_.

** Resposta:

#+ATTR_LATEX: :width 0.8\linewidth
| Propriedade                             | Ferramenta            |
|-----------------------------------------+-----------------------|
| Deve ser r√°pido                         | [[https://ziglang.org/][Zig]]                   |
| Gr√°ficos f√°ceis                         | [[https://www.raylib.com/][Raylib]]                |
| Uma fonte √∫nica de verdade              | [[https://www.postgresql.org/][PostgreSQL]] + [[https://omnigres.com/][Omnigres]] |
| Server distribu√≠do e tolerante a falhas | [[https://www.erlang.org/][Erlang/OTP]]            |
| Ambiente de desenvolvimento             | Nix Shells e [[https://nixos.org/][NixOS]]    |

* Zig

** Zig \leftrightarrow Raylib

#+ATTR_BEAMER: :overlay +-
+ [[https://ziglang.org/][Zig]]: Uma linguagem de programa√ß√£o focada em *desempenho*, *seguran√ßa* e *controle
  expl√≠cito* sobre a mem√≥ria, tamb√©m fornece boa *interoperabilidade* com C.

+ [[https://www.raylib.com/][raylib]]: Uma biblioteca para criar aplicativos gr√°ficos e jogos, que fornece
  uma API simples para gr√°ficos, entrada e √°udio.

#+CAPTION: Lyceum, pre v0.1.0.
#+NAME: fig:lyceum-pre-v0-1-0
#+ATTR_LATEX: :width 0.5\linewidth
[[./img/lyceum_pre_v_0_1_0.png]]

** Zig \harr C Nodes \leftrightarrow ~Erl_Interface~

*** Interface com Erlang
:PROPERTIES:
:BEAMER_ENV: block
:END:

#+ATTR_BEAMER: :overlay +-
+ ~C Nodes~ s√£o programas que atuam como n√≥s ocultos dentro de um sistema Erlang
  distribu√≠do, permitindo que aplica√ß√µes escritas em linguagens n√£o suportadas
  nativamente pela BEAM participem de clusters Erlang.
+ Utilizam a biblioteca ~Erl_Interface~ para se comunicar com outros n√≥s via
  TCP/IP, como se fossem n√≥s Erlang nativos.
+ A ~Erl_Interface~ fornece fun√ß√µes para integrar programas em C com sistemas
  Erlang, servindo como base para a cria√ß√£o de ~C Nodes~.

** Zerl

*** Estabelecendo a ponte entre Erlang e Zig
:PROPERTIES:
:BEAMER_ENV: block
:END:

#+ATTR_BEAMER: :overlay +-
+ Inicialmente uma biblioteca interna do jogo, foi criada para traduzir de forma
  idiom√°tica tipos em Zig \rightarrow Erlang (e vice versa).
+ Depois de v√°rias itera√ß√µes e redesigns acabou virando um pacote separado.
+ Wrapper para a ~Erl_Interface~.

** Func Prog Sweden (2024)

#+CAPTION: [[https://www.youtube.com/watch?v=ejYcWRERetM][Zerl: Making Zig in the BEAM an ez time]], Eduardo Lemos.
#+NAME: fig:zerl-presentation
[[./img/zerl_presentation.jpg]]

* Nix (Parte I)

** Como montar o ambiente de desenvolvimento?

+ Zig
+ Erlang
+ PostgreSQL (com extens√µes)

** Como modelar depend√™ncias

#+begin_src shell 
  nix-store --query \
    --graph $(readlink -f $(which python)) > python.dot
  dot -Tps python.dot -o img/nix_python.png
  rm python.dot
#+end_src

#+CAPTION: Todas as depend√™ncias necess√°rias para rodar o interpretador do Python 3.13 
#+ATTR_LATEX: :width \linewidth
[[./img/nix_python.png]]

** O que √© Nix?

#+ATTR_LATEX: :width 0.7\linewidth
[[./img/nix_the_declarative_trinity.png]]

** Nix (Linguagem)

Nix √© uma linguagem de programa√ß√£o pura, funcional, /lazy/, declarativa e reproduz√≠vel.

#+begin_quote
Reprodutibilidade √© um conceito de design de software, onde uma opera√ß√£o para as
mesmas entradas produz a mesma sa√≠da.
#+end_quote

** Nix (Gerenciador de pacotes)

#+ATTR_BEAMER: :overlay +-
+ ~nix~ √© um gerenciador de pacotes puramente funcional.
+ Trata pacotes como *valores* em linguagens de programa√ß√£o puramente funcionais.
+ Sempre compila todo o /fecho transitivo/ (ou √°rvore de depend√™ncias) de um
  pacote, por√©m, se uma depend√™ncia j√° estiver presente na ~/nix/store/~ (ou num
  cache remoto), o ~nix~ pode us√°-la, o que significa que pode fornecer
  compila√ß√µes incrementais.

** Nixpkgs

#+CAPTION: Fonte: [[https://repology.org/repositories/graphs][Repology]] 
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/nix_repology.png]]


** Nix Store (I)
:PROPERTIES:
:BEAMER_envargs: [allowframebreaks]
:END:

#+ATTR_BEAMER: :overlay +-
+ Armazenamento imut√°vel: Todos os pacotes, configura√ß√µes e depend√™ncias residem
  na ~/nix/store~ de forma ~read-only~, com caminhos derivados a partir de um hash
  criptogr√°fico:

#+begin_src 
/nix/store/b6gvzjyb2pg(...)54ad73z-firefox-33.1
|---------||----------------------||-----------|
  store             digest             name
#+end_src

+ Cada caminho na ~/nix/store/~ inclui um hash computado a partir de toda a
  deriva√ß√£o do pacote (todas as entradas: c√≥digo-fonte, depend√™ncias,
  configura√ß√µes de compila√ß√£o, ambiente, etc.), garantindo que at√© mesmo a menor
  altera√ß√£o produza uma nova entrada de armazenamento isolada.

** Nix Store (II)
:PROPERTIES:
:BEAMER_envargs: [allowframebreaks]
:END:

#+ATTR_BEAMER: :overlay +-
+ Garbage collection: Pacotes antigos ou n√£o utilizados permanecem at√© serem
  explicitamente removidos com ~nix-collect-garbage~.

+ Sustenta o modelo funcional de gerenciamento de pacotes do Nix, permitindo
  *compila√ß√µes reproduz√≠veis*, *atualiza√ß√µes at√¥micas* e *rollbacks*.

#+ATTR_LATEX: :width 0.4\linewidth
[[./img/nix_store.png]]

** Gera√ß√µes (e rollbacks)

#+ATTR_LATEX: :width 0.8\linewidth
#+CAPTION: Fonte: [[https://nixos.org/guides/how-nix-works/][How NixOS works]] 
[[./img/nix_generations.png]]

** NixOS

+ Distribui√ß√£o GNU/Linux, completamente configur√°vel e gerenci√°vel via Nix
  (linguagem) e ~nix~ (gerenciador de pacotes).
+ /Infrastructure as code/ desde 2003.
+ O estado do sistema √© uma sa√≠da de tudo que est√° sua configura√ß√£o (em Nix).

** Nix n√£o √© Docker
#+BEGIN_QUOTE
"Mas n√≥s j√° temos o Docker..."
#+END_QUOTE

+ Num ~Dockerfile~, voc√™ tem garantias de que um *mesmo comando* vai ser rodado na
  *mesma ordem*, ou seja:
  * Isso n√£o significa que voc√™ vai ter o mesmo resultado *sempre*.
  * *Repetibilidade* n√£o √© *reprodutibilidade*.

** Nix Shells

#+begin_src shell
  $ hello
  hello: command not found
  $ nix shell nixpkgs#hello nixpkgs#cowsay
  $ hello
  Hello, world!
  $ cowsay "Hello, world!"
   _______________
  < Hello, world! >
   ---------------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
#+end_src
#+CAPTION: Fonte:[[https://nixos-and-flakes.thiscute.world/development/intro#creating-a-custom-shell-environment-with-nix-shell][NixOS and Flakes book]] 

** Nix Shells (e Devenv)

Para desenvolvimento local, usamos Nix Shells e [[https://devenv.s/h][devenv.sh]].

+ Configura√ß√£o declarativa, que tamb√©m permite a _composi√ß√£o_ de ambientes diferentes.
+ Configura√ß√£o integrada para linguagens populares (Python, Rust, PHP,
  JavaScript, etc).
+ M√≥dulos para servi√ßos populares como PostgreSQL, Redis, MySQL, RabbitMQ, etc.
+ Gerenciamento de processos, suporte para ~git~ hooks.
+ Acesso a todos pacotes do [[https://search.nixos.org/packages?channel=unstable&][nixpkgs]] (atualmente mais the 120K).

** Devenv (Demo #1)

#+begin_src shell
  cd lyceum
  nix develop --impure
#+end_src

ou, se voc√™ estiver usando [[https://github.com/direnv/direnv][direnv]] (com [[https://github.com/nix-community/nix-direnv][nix-direnv]])

#+begin_src shell
  cd lyceum
#+end_src

seguindo dos seguintes comandos (em shells diferentes):

#+begin_src shell
  devenv up
  server
  client-release
#+end_src

* Erlang

** Erlang Node

#+CAPTION: [cite: @beambook p.10 chapter.1 part.1.3.2]
#+ATTR_LATEX: :width 0.7\linewidth
[[./img/erlang_node.png]]

** Criando Processos com ~spawn/3~

#+ATTR_LATEX: :width 0.7\linewidth
#+begin_src erlang
  Pid2 = spawn(ModName, FuncName, [Arg1, ..., ArgN]).
#+end_src

#+NAME: erlang-process
#+BEGIN_SRC dot :file ./img/erlang_process.png :cmdline -Kdot -Tpng :exports results
  digraph Spawn {
    node [shape=circle];
    sep = 1;
  
    pid1 [label="Pid 1", fontsize="10pt", style=filled, fillcolor=grey];
    pid2 [label="Pid 2", xlabel="Mod:Func(Args)", fontsize="10pt", style=filled, fillcolor=white];
  
    pid1 -> pid2 [label="  Spawn(Mod, Func, Args)", fontsize="10pt", minlen=1, style=dashed];
  }
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+CAPTION: [cite:@cesarini2016designing p.29 chapter.2]
#+RESULTS: erlang-process
[[file:./img/erlang_process.png]]

** Message Passing

#+ATTR_LATEX: :width 0.7\linewidth
#+begin_src erlang
  Pid2 ! { Pid1, hello }.
#+end_src

#+NAME: erlang-message-passing
#+BEGIN_SRC dot :file ./img/erlang_message_passing.png :cmdline -Kdot -Tpng :exports results
  digraph Send {
    node [shape=circle];
    rankdir="LR";

    pid1 [label="Pid 1", xlabel="Pid2 ! { self(), hello }", fontsize="10pt", style=filled, fillcolor=grey];
    pid2 [label="Pid 2", fontsize="10pt", style=filled, fillcolor=white, xlabel="receive (...) end." ];

    pid1 -> pid2 [label="{ Pid1, hello }", fontsize="10pt", style=dashed];
  }
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+RESULTS: erlang-message-passing
[[file:./img/erlang_message_passing.png]]

** Anatomia de um Processo

#+NAME: erlang-process-skeleton
#+BEGIN_SRC dot :file ./img/erlang_process_skeleton.png :cmdline -Kdot -Tpng :exports results
  digraph Process {
    node [fontsize="10pt", style=filled];
    
    start [label="Start", fillcolor=gray, shape=circle];
    stop [label="Stop", fillcolor=red, shape=circle];
    init [label="Initialize", xlabel="Mod:Func(Args)", fillcolor=yellow, shape=rectangle];
    loop [label="Receive/Eval Loop", fillcolor=green, shape=rectangle]
    terminate [label="Terminate", fillcolor=yellow, shape=rectangle];

    start -> init [label="  Spawn(Mod, Func, Args)", fontsize="10pt", minlen=1];
    init -> loop
    loop -> loop
    stop -> loop
    loop -> terminate
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+CAPTION: [cite:@cesarini2016designing p.55 chapter.3]
#+RESULTS: erlang-process-skeleton
[[file:./img/erlang_process_skeleton.png]]

** OTP (Open Telecom Platform)

#+BEGIN_QUOTE
OTP √© um conjunto de frameworks, princ√≠pios e padr√µes que guiam e alicer√ßam a
estrutura, design, implementa√ß√£o e deploys de sistemas baseados em Erlang. Usar
OTP sem seus projetos vai te ajudar a evitar *complexidade acidental: coisas que
s√£o dif√≠ceis por que voc√™ escolheu ferramentas inadequadas*.

[cite:@cesarini2016designing p.4]
#+END_QUOTE

** OTP Applications

+ Uma ~Application~ √© um constructor b√°sico para deploy de projetos em Erlang/OTP.
+ S√£o processos que ser iniciados, interrompidos e gerenciadas de forma independente.

** OTP Supervisors

#+begin_quote
A supervision tree is a tree of processes. The upper processes (supervisors) in
the tree monitor the lower processes (workers) in the tree and restart the lower
processes if they fail. [cite:@armstrong2013 p.398]
#+end_quote

Independentemente do que os processos monitados fa√ßam, um supervisor funciona
sempre do mesmo modo e seu funcionao pode ser dividido em duas categorias:

+ Uma parte gen√©rica que lida com a cria√ß√£o, monitoramento e ~restart~ de
  processos filhos.
+ Uma especifica√ß√£o de como os processos filhos devem ser iniciados e reiniciados.

** OTP Supervisors (~one_for_one~)

+ ~one_for_one~ :: Se um processo monitorado morre, deve ser reiniciado.

#+NAME: fig:erlang-supervisor-o4o
#+BEGIN_SRC dot :file ./img/erlang_supervisor_o4o.png :cmdline -Kdot -Tpng :exports results
  graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
        label="", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
  	]

  	sup [label="S", pos="1,1"]
  	w1 [pos="0,0"]
  	w2 [pos="0,1"]
  	w3 [label="üî•", pos="0,2"]
  	w4 [pos="0,3"]

  	sup -- w1
  	sup -- w2
  	sup -- w3
  	sup -- w4
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: fig:erlang-supervisor-o4o
[[file:./img/erlang_supervisor_o4o.png]]

** OTP Supervisors (~one_for_all~)

+ ~one_for_all~ :: Se um processo monitorado morre, todos devem ser reiniciado.

#+NAME: fig:erlang-supervisor-o4a
#+BEGIN_SRC dot :file ./img/erlang_supervisor_o4a.png :cmdline -Kdot -Tpng :exports results
  graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
        label="‚ü≥", 
        xlabel="",
        shape=circle,
        fixedsize=true,
        width=0.3,
        color="black",
        fillcolor="#eeeeee",
        style="filled,solid",
        fontsize=12
  	]

  	sup [label="S", pos="1,1"]
  	w1 [pos="0,0"]
  	w2 [pos="0,1"]
  	w3 [label="üî•", pos="0,2"]
  	w4 [pos="0,3"]

  	sup -- w1
  	sup -- w2
  	sup -- w3
  	sup -- w4
  }
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: fig:erlang-supervisor-o4a
[[file:./img/erlang_supervisor_o4a.png]]

** ~gen_server~ (I)

+ Fornece uma interface para implementar processos que respondem a requisi√ß√µes
  s√≠ncronas (~call~) e ass√≠ncronas (~cast~).

#+NAME: fig:erlang-client-server
#+BEGIN_SRC dot :file ./img/erlang-client-server.png :cmdline -Kneato -Tpng :exports results
digraph client_server {
    rankdir=LR;
    node [shape=circle, label="", style=filled, fillcolor=white, width=0.8];
    edge [fontsize=10, width=0.5];
    
    // Clients
    client1 [xlabel="Client 1", pos="0,2!"];
    client2 [xlabel="Client 2", pos="0,1!"];  
    client3 [xlabel="Client 3", pos="0,0!"];
    
    // Server
    server [xlabel="Server", pos="4,1!"];
        
    // Query/Reply arrows
    client1 -> server [style=solid];
    client2 -> server [style=solid];
    client3 -> server [style=solid];
     
    server -> client1 [style=dashed];
    server -> client2 [style=dashed];
    server -> client3 [style=dashed];
}
#+END_SRC

#+ATTR_LATEX: :width 0.7\linewidth
#+RESULTS: fig:erlang-client-server
[[file:./img/erlang-client-server.png]]

** ~gen_server~ (II)

+ Gerenciamento de ciclo de vida padronizado: inicializa√ß√£o e outras transi√ß√µes
  de estado s√£o feitas de forma consistente.
+ Podem ser facilmente integrados em √°rvores de supervis√£o.

#+NAME: fig:erlang-gen_server
#+BEGIN_SRC dot :file ./img/erlang-gen_server.png :cmdline -Kdot -Tpng :exports results
digraph gen_server {
  rankdir=LR;
  node [shape=box, style=filled];
  edge [dir=both];
  
  graph [margin=0.2];
  
  api [label="API\n\nstart_link()\n(...)", 
        fillcolor=lightblue, 
        width=2, 
        height=1.5,
        fontsize=12];
  
  process [label="gen_server\nProcess", 
            shape=circle, 
            fillcolor=gray70,
            width=1.2,
            fontsize=11];
  
  callbacks [label="Callback Module\n\ninit/1\nhandle_call/3\nhandle_cast/2\nterminate/2", 
              fillcolor=lightcyan,
              width=2,
              height=1.5,
              fontsize=12];
  
  api -> process [arrowhead=normal, arrowtail=normal];
  process -> callbacks [arrowhead=normal, arrowtail=normal];
}
#+END_SRC

#+ATTR_LATEX: :width 0.7\linewidth
#+CAPTION: [cite:@cesarini2016designing p.58 chapter.3]
#+RESULTS: fig:erlang-gen_server
[[file:./img/erlang-gen_server.png]]
** ~gen_statem~ (I)

#+ATTR_BEAMER: :overlay +-
+ Gerenciamento de Estado Estruturado: Oferece uma interface para implementar
  m√°quinas de estados finitos com estados e transi√ß√µes bem definidos.
+ Processamento Orientado a Eventos: Lida com m√∫ltiplos tipos de eventos
  (chamadas, convers√µes, mensagens informativas, timeouts) e os encaminha para
  manipuladores de estado apropriados, com suporte para adiamento de eventos e
  gera√ß√£o interna de eventos.

** ~gen_statem~ (II)

#+ATTR_BEAMER: :overlay +-
+ Cada jogador no Lyceum √© um processo com ~gen_statem~.

#+CAPTION: Fonte: [[https://erlang.org/documentation/doc-10.0/doc/design_principles/statem.html][gen_statem docs]] 
#+ATTR_LATEX: :width 0.3\linewidth
[[./img/erlang_gen_statem.png]]

** Combinando as Estruturas (I)

#+NAME: erlang-app-structure
#+BEGIN_SRC dot :file ./img/erlang_app_structure.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Supervisor", pos="1,1", fillcolor="blue"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  w4 [label="P4", pos="0,3"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
  sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure
[[file:./img/erlang_app_structure.png]]

** Combinando as Estruturas (II)

#+NAME: erlang-app-structure-ii
#+BEGIN_SRC dot :file ./img/erlang_app_structure_ii.png :cmdline -Kdot -Tpng :exports results
graph g {
  	ratio=fill
  	splines=spline
  	overlap=scale

  	node [
  		label="", 
  		xlabel="",
  		shape=circle,
  		fixedsize=true,
  		width=0.3,
  		color="black",
  		fillcolor="white",
  		style="filled,solid",
  		fontsize=12
  	]

  	app [xlabel="Application", pos="1,1", fillcolor="red"]
  	sup [xlabel="Top Level Supervisor", pos="1,1", fillcolor="blue"]
  	isup [xlabel="Inner Supervisor", pos="0,0", fillcolor="blue"]
	
	iw1 [label="P1", pos="0,1"]
	iw2 [label="P2", pos="0,1"]
  	w2 [label="P3", pos="0,1"]
  	w3 [label="P4", pos="0,2"]
  	w4 [label="P5", pos="0,3"]

  	app -- sup
  	sup -- isup
	isup -- iw1
	isup -- iw2
  	sup -- w2
  	sup -- w3
  	sup -- w4
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-ii
[[file:./img/erlang_app_structure_ii.png]]

** Combinando as Estruturas (III)

#+NAME: erlang-app-structure-iii-1
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iii_1.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="#90D5FF"]

  app -- sup
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-iii-1
[[file:./img/erlang_app_structure_iii_1.png]]

** Combinando as Estruturas (III)

#+NAME: erlang-app-structure-iii-2
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iii_2.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="#90D5FF"]
  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]
  
  app -- sup
  sup -- w1
  sup -- w2
  sup -- w3
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-app-structure-iii-2
[[file:./img/erlang_app_structure_iii_2.png]]

** Combinando as Estruturas (IV)

#+NAME: erlang-app-structure-iv
#+BEGIN_SRC dot :file ./img/erlang_app_structure_iv.png :cmdline -Kdot -Tpng :exports results
graph g {
  ratio=fill
  splines=spline
  overlap=scale
  
  node [
    label="", 
    xlabel="",
    shape=circle,
    fixedsize=true,
    width=0.3,
    color="black",
    fillcolor="white",
    style="filled,solid",
    fontsize=12
  ]
  
  app [xlabel="Application", pos="1,1", fillcolor="red"]
  sup1 [xlabel="Dynamic Supervisor", pos="1,1", fillcolor="#90D5FF"]
  sup2 [pos="1,2", fillcolor="blue"]
  sup3 [pos="1,3", fillcolor="blue"]
  sup4 [pos="1,4", fillcolor="#90D5FF"]
  sup5 [pos="1,5", fillcolor="#90D5FF"]

  w1 [label="P1", pos="0,0"]
  w2 [label="P2", pos="0,1"]
  w3 [label="P3", pos="0,2"]

  w4 [label="P4", pos="0,3"]
  w5 [label="P5", pos="0,4"]

  w6 [label="P6", pos="0,5"]
  w7 [label="P7", pos="0,6"]

  w8 [label="P8", pos="0,7"]
  w9 [label="P9", pos="0,8"]
  
  app -- sup1
  app -- sup2
  app -- sup3
  sup1 -- w1
  sup1 -- w2
  sup1 -- w3

  sup2 -- w4
  sup2 -- w5

  sup3 -- sup4
  sup3 -- sup5

  sup4 -- w6
  sup4 -- w7

  sup5 -- w8
  sup5 -- w9
}
#+END_SRC

#+ATTR_LATEX: :width 0.8\linewidth
#+RESULTS: erlang-app-structure-iv
[[file:./img/erlang_app_structure_iv.png]]

** Releases

+ M√≥dulos: O n√≠vel mais baixo de encapsulamento.
+ ~Applications~: Um agrupamento m√≥dulos, estrutura de n√≠vel intermedi√°rio.
+ ~Releases~: Um agrupamento de uma ou mais aplica√ß√µes.

#+NAME: erlang-release
#+BEGIN_SRC dot :file ./img/erlang_release.png :cmdline -Kdot -Tpng :exports results
graph Release {
  ratio=fill
  splines=spline
  overlap=scale
  
  subgraph cluster_release {
    label="App v0.1.0"
    
    node [
      label="", 
      xlabel="",
      shape=circle,
      fixedsize=true,
      width=0.3,
      color="black",
      fillcolor="white",
      style="filled,solid",
      fontsize=12
    ]
    
    app [pos="1,1", fillcolor="red"]
    sup1 [pos="1,1", fillcolor="#90D5FF"]
    sup2 [pos="1,2", fillcolor="blue"]
    sup3 [pos="1,3", fillcolor="blue"]
    sup4 [pos="1,4", fillcolor="#90D5FF"]
    sup5 [pos="1,5", fillcolor="#90D5FF"]

    w1 [label="P1", pos="0,0"]
    w2 [label="P2", pos="0,1"]
    w3 [label="P3", pos="0,2"]

    w4 [label="P4", pos="0,3"]
    w5 [label="P5", pos="0,4"]

    w6 [label="P6", pos="0,5"]
    w7 [label="P7", pos="0,6"]

    w8 [label="P8", pos="0,7"]
    w9 [label="P9", pos="0,8"]
    
    app -- sup1
    app -- sup2
    app -- sup3
    sup1 -- w1
    sup1 -- w2
    sup1 -- w3

    sup2 -- w4
    sup2 -- w5

    sup3 -- sup4
    sup3 -- sup5

    sup4 -- w6
    sup4 -- w7

    sup5 -- w8
    sup5 -- w9
  }
}
#+END_SRC

#+ATTR_LATEX: :width 0.5\linewidth
#+RESULTS: erlang-release
[[file:./img/erlang_release.png]]

** Umbrellas

#+NAME: erlang-umbrella
#+BEGIN_SRC dot :file ./img/erlang_umbrella.png :cmdline -Kdot -Tpng :exports results
digraph ServerUmbrella {
  rankdir=TB;
  compound=true;
  newrank=true;
  splines=ortho;
  
  node [shape=box, style=filled, fontname="Arial", fontsize=10, fontcolor=white];
  edge [fontname="Arial", fontsize=5, color="#374151"];
  
  // Umbrella Subgraph
  subgraph cluster_server {
    label="Server Umbrella";
    style=filled;
    fillcolor="#f8fafc";
    color="#0f172a";
    penwidth=4;
    fontcolor="#0f172a";
    fontsize=14;
    
    subgraph cluster_auth {
      label="Auth";
      style=filled;
      fillcolor="#dbeafe";
      color="#1e40af";
      penwidth=3;
      fontsize=12;
      
      AA [label="Auth Application", fillcolor="#1a365d"];
      AS [label="Auth Supervisor", fillcolor="#b91c1c"];
      SAW [label="Simple Auth Worker", fillcolor="#059669"];

      AA -> AS;
      AS -> SAW;
    }
    
    subgraph cluster_world {
      label="World";
      style=filled;
      fillcolor="#dcfce7";
      color="#16a34a";
      penwidth=3;
      fontsize=12;
      
      WA [label="World Application", fillcolor="#1a365d"];
      WS [label="World Supervisor", fillcolor="#b91c1c"];
      WM [label="World Migrations", fillcolor="#059669"];
      WM1 [label="Map 1", fillcolor="#059669"];

      WA -> WS;
      WS -> WM1;
      WS -> WM;
    }
    
    subgraph cluster_player {
      label="Player";
      style=filled;
      fillcolor="#fed7aa";
      color="#ea580c";
      penwidth=3;
      fontsize=12;
      
      PA [label="Player Application", fillcolor="#1a365d"];
      TPLS [label="Top-Level Supervisor", fillcolor="#dc2626"];
      DPS1 [label="Dynamic Supervisor", fillcolor="#aa3600"];
      DPS2 [label="Dynamic Supervisor", fillcolor="#aa3600"];
      DPS3 [label="Dynamic Supervisor", fillcolor="#aa3600"];
      DPSN [label="Dynamic Supervisor", fillcolor="#aa3600"];

      P1 [label="Player 1", fillcolor="#059669"];
      P2 [label="Player 2", fillcolor="#059669"];
      P3 [label="Player 3", fillcolor="#059669"];
      PN [label="Player N", fillcolor="#059669"];

      PA -> TPLS;
  
      TPLS -> DPS1;
      DPS1 -> P1;

      TPLS -> DPS2;
      DPS2 -> P2;

      TPLS -> DPS3;
      DPS3 -> P3;

      TPLS -> DPSN;
      DPSN -> PN;
    }
    
    subgraph cluster_cache {
      label="Cache";
      style=filled;
      fillcolor="#f3e8ff";
      color="#9333ea";
      penwidth=3;
      fontsize=12;
      
      CA [label="Cache Application", fillcolor="#1a365d"];
      CS [label="Cache Supervisor", fillcolor="#b91c1c"];
      CW [label="Cache Worker", fillcolor="#059669"];
      MNESIA [label="MNESIA", shape=cylinder, fillcolor="#374151"];

      CA -> CS;
      CS -> CW;
      CW -> MNESIA [dir=both];
    }
    
    subgraph cluster_libraries {
      label="Utility Libraries";
      style=filled;
      fillcolor="#f1f5f9";
      color="#475569";
      penwidth=3;
      fontsize=12;
      fontname="Arial Bold";
      
      LPG [label="PostgreSQL Library", fillcolor="#7c3aed", style="filled,dashed"];
      LMAP [label="Map Library", fillcolor="#7c3aed", style="filled,dashed"];
    }
  }
}
#+END_SRC

#+ATTR_LATEX: :width \linewidth
#+RESULTS: erlang-umbrella
[[file:./img/erlang_umbrella.png]]

* PostgreSQL

** L√≥gica no banco!

#+CAPTION: Updatable View
#+NAME: fig:sql-omnigres-du
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/sql_updatable_views.png]]

** Omnigres (I)

+ Uma extens√£o para o PostgreSQL visa oferecer melhor qualidade de vida para o
  desenvolvimento de aplica√ß√µes, oferece baterias para lidar com tr√°fego
  HTTP/WebSockets, roteamento e consultas reativas, etc.
+ Integra√ß√µes avan√ßadas: Inclui componentes como ~omni_httpd~ (servidor HTTP),
  ~omni_session~ (sess√µes), ~omni_vfs~ (sistema de arquivos virtual), ~omni_types~
  (Discriminated Unions), ~omni_ledger~, etc.

** Omnigres (II)

#+CAPTION: Como ter sum types em PostgreSQL
#+NAME: fig:sql-omnigres-du
#+ATTR_LATEX: :width 0.8\linewidth
[[./img/sql_omnigres_du.png]]

* Nix (Parte II)

** Builds Puras (Demo #3)

#+begin_src shell
  # Server
  nix build .#server

  # Client
  nix build .#client
#+end_src

** OCI Images (Demo #4)

#+begin_src shell
  # OCI Image
  nix build .#dockerImage
  docker load < ./result
  docker container run --network=host lyceum:latest
#+end_src

* NixOS

** Servidor NixOS Declarativo

+ 
  
** NixOS (Demo #5)

#+TODO: Finish V2 deploy

* Fim

:PROPERTIES:
:BEAMER_env: appendix
:END:

** Conclus√£o

#+ATTR_BEAMER: :overlay +-
+ Composi√ß√£o √© uma propriedade fundamental para alavancar at√© mesmo as ideias
  mais bizzaras.
+ Fundamenta√ß√£o te√≥rica s√≥lida tem um efeito multiplicador em termos de
  produtividade.
+ Nix >>>>>>>> docker et al.

** Perguntas?

*** Projetos
:PROPERTIES:
:BEAMER_ENV: block
:END:
- [[https://github.com/Dr-Nekoma/lyceum][Lyceum]]
- [[https://github.com/dont-rely-on-nulls/zerl][Zerl]]
- [[https://github.com/Dr-Nekoma/trashcan][Trashcan]]

*** Slides
:PROPERTIES:
:BEAMER_ENV: block
:END:
- [[https://github.com/dont-rely-on-nulls/gambiconf-2025][Gambiconf 2025]]: Uma "demo secreta", visto que todos os slides tamb√©m foram
  feitos num ambiente Nix com Emacs + Orgmode + LaTeX, cont√©m inclusive uma
  vers√£o customizada do Emacs para buildar os slides em CI.

** Bibliografia
  :PROPERTIES:
  :BEAMER_OPT: fragile,allowframebreaks,label=
  :END:      

#+print_bibliography:
